#!/usr/bin/python

# This file is part of Openplotter.
# Copyright (C) 2015 by sailoog <https://github.com/sailoog/openplotter>
#
# Openplotter is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# any later version.
# Openplotter is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Openplotter. If not, see <http://www.gnu.org/licenses/>.

import ConfigParser, ujson, os, io, pyudev, re, requests, subprocess, sys, time, webbrowser, wx, wx.lib.scrolledpanel, serial, shutil
from datetime import datetime
from wx.lib.mixins.listctrl import CheckListCtrlMixin, ListCtrlAutoWidthMixin
try:
	from classes.add_DS18B20 import addDS18B20
except:
        addDS18B20 = None
from classes.edit_MCP import editMCP
from classes.add_i2c import addI2c
from classes.edit_i2c import editI2c
from classes.add_kplex import addkplex
from classes.add_tool10 import addTool10
from classes.add_value_setting import addvaluesetting
from classes.add_deviation_setting import adddeviationsetting
from classes.add_SK_to_N2K import addSKtoN2K
from classes.conf import Conf
from classes.SK_settings import SK_settings
from classes.language import Language
from classes.nodes import Nodes, TriggerSK, TriggerGeofence, TriggerGPIO, TriggerMQTT, TriggerTelegram, TriggerTime, Condition, ActionSetSignalkKey, ActionSetGPIO, ActionSetMQTT, ActionPublishTwitter, ActionSendEmail, ActionPlaySound, ActionRunCommand, ActionSendTelegram

class CheckListCtrl(wx.ListCtrl, CheckListCtrlMixin, ListCtrlAutoWidthMixin):
	def __init__(self, parent, width, height):
		wx.ListCtrl.__init__(self, parent, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER, size=(width, height))
		CheckListCtrlMixin.__init__(self)
		ListCtrlAutoWidthMixin.__init__(self)

class MainFrame(wx.Frame):
	def __init__(self):
		self.conf = conf
		self.home = conf.home
		self.conf_folder = conf.conf_folder
		self.currentpath = currentpath
		self.SK_settings = SK_settings()

		wx.Frame.__init__(self, None, title="OpenPlotter", size=(710, 460))
		if self.util_process_exist('startup.py'):
			print "System not ready, try later."
			sys.exit(0)
		self.Bind(wx.EVT_CLOSE, self.when_closed)
		self.SetFont(wx.Font(10, wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL))
		self.language = self.conf.get('GENERAL', 'lang')
		Language(self.conf)
		self.p = wx.lib.scrolledpanel.ScrolledPanel(self, -1, style=wx.TAB_TRAVERSAL | wx.SUNKEN_BORDER)
		self.p.SetAutoLayout(1)
		self.p.SetupScrolling()
		self.nb = wx.Notebook(self.p)
		self.p_serial = wx.Panel(self.nb)
		self.p_kplex = wx.Panel(self.nb)
		self.p_n2k = wx.Panel(self.nb)
		self.p_wifi = wx.Panel(self.nb)
		self.p_pypilot = wx.Panel(self.nb)
		self.p_action = wx.Panel(self.nb)
		self.p_i2c = wx.Panel(self.nb)
		self.p_1w = wx.Panel(self.nb)
		self.p_spi = wx.Panel(self.nb)
		self.p_credentials = wx.Panel(self.nb)
		self.p_mqtt = wx.Panel(self.nb)
		self.p_startup = wx.Panel(self.nb)
		self.p_dashboards = wx.Panel(self.nb)
		self.nb.AddPage(self.p_serial, _('Serial'))
		self.nb.AddPage(self.p_kplex, 'Kplex')
		self.nb.AddPage(self.p_pypilot, _('pypilot'))
		self.nb.AddPage(self.p_n2k, 'CAN')
		self.nb.AddPage(self.p_wifi, _('Network'))
		self.nb.AddPage(self.p_action, _('Actions'))
		self.nb.AddPage(self.p_credentials, _('Credentials'))
		self.nb.AddPage(self.p_i2c, _('I2C'))
		self.nb.AddPage(self.p_1w, '1W')
		self.nb.AddPage(self.p_spi, 'SPI')
		self.nb.AddPage(self.p_startup, _('Settings'))
		self.nb.AddPage(self.p_dashboards, _('Dashboards'))
		sizer = wx.BoxSizer()
		sizer.Add(self.nb, 1, wx.EXPAND)
		self.p.SetSizer(sizer)
		self.help_bmp = wx.Bitmap(self.currentpath + "/static/icons/help-browser.png", wx.BITMAP_TYPE_ANY)
		self.icon = wx.Icon(self.currentpath + '/static/icons/openplotter.ico', wx.BITMAP_TYPE_ICO)
		self.SetIcon(self.icon)
		self.CreateStatusBar()
		font_statusBar = self.GetStatusBar().GetFont()
		font_statusBar.SetWeight(wx.BOLD)
		self.GetStatusBar().SetFont(font_statusBar)
		self.GetStatusBar().SetForegroundColour(wx.BLACK)
		self.nb.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.Changingpage)
		self.Centre()

		###########################menu

		self.menubar = wx.MenuBar()
		self.settings = wx.Menu()
		self.sdr_ais_item1 = self.settings.Append(wx.ID_ANY, _('SDR receiver'),
												  _('Set an SDR receiver in the new window'))
		self.Bind(wx.EVT_MENU, self.open_sdr_ais, self.sdr_ais_item1)
		self.deviation_table = self.settings.Append(wx.ID_ANY, _('Deviation Table'),
													_('Create a deviation table for your boat'))
		self.Bind(wx.EVT_MENU, self.on_deviation_table, self.deviation_table)

		self.nmea_0183_item1 = self.settings.Append(wx.ID_ANY, _('NMEA 0183 generator'),
													_('Generate NMEA 0183 from current values'))
		self.Bind(wx.EVT_MENU, self.open_nmea_0183, self.nmea_0183_item1)
		self.settings.AppendSeparator()

		self.tools_py = []
		if self.conf.has_section('TOOLS'):
			if self.conf.has_option('TOOLS', 'py'):
				data = self.conf.get('TOOLS', 'py')
				try:
					temp_list = eval(data)
				except:
					temp_list = []
				if type(temp_list) is list:
					pass
				else:
					temp_list = []
				for ii in temp_list:
					self.tools_py.append(ii)

		self.tool10_b = []
		index = 0
		for i in self.tools_py:
			self.tool10_b.append(0)
			self.tool10_b[index] = self.settings.Append(index, i[0], i[1])
			self.Bind(wx.EVT_MENU, self.tool10, self.tool10_b[index])
			index += 1
		self.menubar.Append(self.settings, _('Tools'))

		self.lang = wx.Menu()
		self.lang_item8 = self.lang.Append(wx.ID_ANY, _('Basque'), _('Set Basque language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_eu, self.lang_item8)
		self.lang_item2 = self.lang.Append(wx.ID_ANY, _('Catalan'), _('Set Catalan language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_ca, self.lang_item2)
		self.lang_item5 = self.lang.Append(wx.ID_ANY, _('Dutch'), _('Set Dutch language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_nl, self.lang_item5)		
		self.lang_item1 = self.lang.Append(wx.ID_ANY, _('English'), _('Set English language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_en, self.lang_item1)
		self.lang_item10 = self.lang.Append(wx.ID_ANY, _('Finnish'), _('Set Finnish language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_fi, self.lang_item10)
		self.lang_item4 = self.lang.Append(wx.ID_ANY, _('French'), _('Set French language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_fr, self.lang_item4)
		self.lang_item9 = self.lang.Append(wx.ID_ANY, _('Galician'), _('Set Galician language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_gl, self.lang_item9)
		self.lang_item6 = self.lang.Append(wx.ID_ANY, _('German'), _('Set German language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_de, self.lang_item6)
		self.lang_item11 = self.lang.Append(wx.ID_ANY, _('Greek'), _('Set Greek language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_el, self.lang_item11)
		self.lang_item7 = self.lang.Append(wx.ID_ANY, _('Italiano'), _('Set Italian language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_it, self.lang_item7)
		self.lang_item3 = self.lang.Append(wx.ID_ANY, _('Spanish'), _('Set Spanish language'), kind=wx.ITEM_CHECK)
		self.Bind(wx.EVT_MENU, self.lang_es, self.lang_item3)
		self.menubar.Append(self.lang, _('Language'))

		self.update = wx.Menu()
		self.opencpn_item1 = self.update.Append(wx.ID_ANY, _('Update OpenCPN'), _('Update OpenCPN to latest stable release'))
		self.Bind(wx.EVT_MENU, self.update_opencpn, self.opencpn_item1)
		self.opencpn_item2 = self.update.Append(wx.ID_ANY, _('Update OpenCPN plugins'), _('Update OpenCPN plugins to latest stable releases'))
		self.Bind(wx.EVT_MENU, self.update_opencpn_plugins, self.opencpn_item2)
		self.update.AppendSeparator()
		self.system_item2 = self.update.Append(wx.ID_ANY, _('Set default OpenPlotter desktop'), _('Run this after a major update'))
		self.Bind(wx.EVT_MENU, self.default_desktop, self.system_item2)		
		self.update.AppendSeparator()
		self.openplotter_item1 = self.update.Append(wx.ID_ANY, _('Update OpenPlotter'), _('Apply latest changes on OpenPlotter and update the system if necessary'))
		self.Bind(wx.EVT_MENU, self.update_openplotter, self.openplotter_item1)
		self.menubar.Append(self.update, _('Updates'))

		self.helpm = wx.Menu()
		self.helpm_item1 = self.helpm.Append(wx.ID_ANY, _('&About'), _('About OpenPlotter'))
		self.Bind(wx.EVT_MENU, self.OnAboutBox, self.helpm_item1)
		self.helpm_item2 = self.helpm.Append(wx.ID_ANY, _('Documentation'),
											 _('OpenPlotter documentation'))
		self.Bind(wx.EVT_MENU, self.op_doc, self.helpm_item2)
		self.menubar.Append(self.helpm, _('&Help'))

		self.SetMenuBar(self.menubar)
		# ##########################menu
		self.page_serial()
		self.page_kplex()
		self.page_n2k()
		self.page_wifi()
		self.page_pypilot()
		self.page_action()
		self.page_i2c()
		self.page_1w()
		self.page_spi()
		self.page_credentials()
		self.page_startup()
		self.page_dashboards()

		self.manual_settings = ''
		self.read_kplex_conf()
		self.read_language()

		self.read_startup()
		self.read_wifi_conf()
		self.read_DS18B20()
		self.read_Serialinst()
		self.read_MCP()
		self.read_i2c()
		self.read_pypilot()
		self.read_n2k()
		self.read_triggers()
		self.print_credentials()
		self.read_dashboards()
		#self.when_closed(0x001)

	###########################################general functions

	def read_language(self):
		if self.language == 'en': self.lang.Check(self.lang_item1.GetId(), True)
		if self.language == 'ca': self.lang.Check(self.lang_item2.GetId(), True)
		if self.language == 'es': self.lang.Check(self.lang_item3.GetId(), True)
		if self.language == 'fr': self.lang.Check(self.lang_item4.GetId(), True)
		if self.language == 'nl': self.lang.Check(self.lang_item5.GetId(), True)
		if self.language == 'de': self.lang.Check(self.lang_item6.GetId(), True)
		if self.language == 'it': self.lang.Check(self.lang_item7.GetId(), True)
		if self.language == 'eu': self.lang.Check(self.lang_item8.GetId(), True)
		if self.language == 'gl': self.lang.Check(self.lang_item9.GetId(), True)
		if self.language == 'fi': self.lang.Check(self.lang_item10.GetId(), True)
		if self.language == 'el': self.lang.Check(self.lang_item11.GetId(), True)

	def ShowMessage(self, w_msg):
		wx.MessageBox(w_msg, 'Info', wx.OK | wx.ICON_INFORMATION)
		
	def ShowStatusBar(self, w_msg, colour):
		self.GetStatusBar().SetForegroundColour(colour)
		self.SetStatusText(w_msg)

	def ShowStatusBarRED(self, w_msg):
		self.ShowStatusBar(w_msg, wx.RED)

	def ShowStatusBarGREEN(self, w_msg):
		self.ShowStatusBar(w_msg, wx.GREEN)

	def ShowStatusBarBLACK(self, w_msg):
		self.ShowStatusBar(w_msg, wx.BLACK)	

	def open_sdr_ais(self, event):
		subprocess.call(['pkill', '-f', 'SDR_AIS.py'])
		subprocess.Popen(['python', self.currentpath + '/tools/SDR_AIS/SDR_AIS.py'])

	def on_deviation_table(self, e):
		dlg = adddeviationsetting(self)
		dlg.ShowModal()
		dlg.Destroy()

	def open_nmea_0183(self, event):
		subprocess.call(['pkill', '-f', 'NMEA_0183_generator.py'])
		subprocess.Popen(['python', self.currentpath + '/tools/NMEA_0183_generator/NMEA_0183_generator.py'])

	def tool10(self, event):
		menuId = event.Id
		dlg = addTool10()
		res = dlg.ShowModal()
		res = dlg.ButtonNr
		dlg.Destroy()
		if res != 4:
			folder = self.tools_py[menuId][2]
			file = folder+'.py'
			if os.path.isfile(self.conf_folder + '/tools/'+folder+'/'+file):
				subprocess.call(['pkill', '-9', '-f', file])					
				if res == 2:
					subprocess.Popen(['python', self.conf_folder + '/tools/'+folder+'/'+file])
				elif res == 1:
					subprocess.Popen(['python', self.conf_folder + '/tools/'+folder+'/'+file, 'settings'])
			else:
				if os.path.isfile(self.currentpath + '/tools/'+folder+'/'+file):
					subprocess.call(['pkill', '-9', '-f', file])					
					if res == 2:
						subprocess.Popen(['python', self.currentpath + '/tools/'+folder+'/'+file])
					elif res == 1:
						subprocess.Popen(['python', self.currentpath + '/tools/'+folder+'/'+file, 'settings'])
				else:
					print 'file not found: ', file

	def clear_lang(self):
		self.lang.Check(self.lang_item1.GetId(), False)
		self.lang.Check(self.lang_item2.GetId(), False)
		self.lang.Check(self.lang_item3.GetId(), False)
		self.lang.Check(self.lang_item4.GetId(), False)
		self.lang.Check(self.lang_item5.GetId(), False)
		self.lang.Check(self.lang_item6.GetId(), False)
		self.lang.Check(self.lang_item7.GetId(), False)
		self.lang.Check(self.lang_item8.GetId(), False)
		self.lang.Check(self.lang_item9.GetId(), False)
		self.lang.Check(self.lang_item10.GetId(), False)
		self.lang.Check(self.lang_item11.GetId(), False)
		self.ShowMessage(_('The selected language will be enabled when you restart'))

	def lang_en(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item1.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'en')

	def lang_ca(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item2.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'ca')

	def lang_es(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item3.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'es')

	def lang_fr(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item4.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'fr')

	def lang_nl(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item5.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'nl')

	def lang_de(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item6.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'de')

	def lang_it(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item7.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'it')

	def lang_eu(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item8.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'eu')

	def lang_gl(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item9.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'gl')

	def lang_fi(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item10.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'fi')

	def lang_el(self, e):
		self.clear_lang()
		self.lang.Check(self.lang_item11.GetId(), True)
		self.conf.set('GENERAL', 'lang', 'el')

	def update_opencpn(self, e):
		subprocess.Popen(['lxterminal', '-e', 'bash', self.currentpath+'/update/update_OpenCPN.sh'])
		self.ShowStatusBarBLACK(_('Follow the instructions of the new window'))

	def update_opencpn_plugins(self, e):
		subprocess.Popen(['lxterminal', '-e', 'bash', self.currentpath+'/update/update_OpenCPN_plugins.sh'])
		self.ShowStatusBarBLACK(_('Follow the instructions of the new window'))

	def update_openplotter(self, e):
		vl = self.conf.get('GENERAL', 'version')
		sl = self.conf.get('GENERAL', 'state')
		vl_list = vl.split('.')
		local_xxx = int(vl_list[0])
		local_oxx = int(vl_list[1])
		local_oox = int(vl_list[2])
		master_github_repositories = self.conf.get('UPDATE', 'master_github_repositories')
		stable_branch = self.conf.get('UPDATE', 'stable_branch')
		beta_branch = self.conf.get('UPDATE', 'beta_branch')
		try:
			r_stable = requests.get('https://raw.githubusercontent.com/'+master_github_repositories+'/openplotter/'+stable_branch+'/openplotter.conf')
			r_beta = requests.get('https://raw.githubusercontent.com/'+master_github_repositories+'/openplotter/'+beta_branch+'/openplotter.conf')
		except:
			self.ShowStatusBarRED(_('It was not possible to connect to Github.'))
			return
		try:
			data_conf = ConfigParser.SafeConfigParser()
			data_conf.readfp(io.StringIO(r_stable.text))
			vr = data_conf.get('GENERAL','version')
			sr = data_conf.get('GENERAL','state')
			vr_list = vr.split('.')
			remote_xxx = int(vr_list[0])
			remote_oxx = int(vr_list[1])
			remote_oox = int(vr_list[2])
		except:
			self.ShowStatusBarRED(_('Error reading versions.'))
			return

		check_beta = True
		if remote_xxx > local_xxx: check_beta = False
		elif remote_xxx == local_xxx and remote_oxx > local_oxx: check_beta = False
		elif remote_xxx == local_xxx and remote_oxx == local_oxx and remote_oox > local_oox: check_beta = False
		if check_beta:
			try:
				data_conf = ConfigParser.SafeConfigParser()
				data_conf.readfp(io.StringIO(r_beta.text))
				vr = data_conf.get('GENERAL','version')
				sr = data_conf.get('GENERAL','state')
				vr_list = vr.split('.')
				remote_xxx = int(vr_list[0])
				remote_oxx = int(vr_list[1])
				remote_oox = int(vr_list[2])
			except:
				self.ShowStatusBarRED(_('Error reading versions.'))
				return
		msg = ''
		if sl == 'stable' and sr != 'stable':
			msg += _('You are running a stable version. If you update to a non stable version you will have to keep updating until a stable stage is reached again.\n\n').decode('utf8')
		if remote_xxx > local_xxx:
			msg += _('There is a major Raspbian upgrade, you have to download the new OpenPlotter image: v').decode('utf8')+str(remote_xxx)+'.x.x '+sr+'.\n'
			self.ShowMessage(msg)
			return
		elif remote_xxx == local_xxx and remote_oxx > local_oxx:
			msg += _('There is a major OpenPlotter update.\n').decode('utf8')
			msg += _('Please make a backup image of your system before updating.\n\n').decode('utf8')
			update_type = 'major'
		elif remote_xxx == local_xxx and remote_oxx == local_oxx and remote_oox > local_oox:
			msg += _('There is a minor OpenPlotter update.\n\n').decode('utf8')
			update_type = 'minor'
		else:
			msg += 'OpenPlotter '+vl+' '+sl+_(' is up to date.\n').decode('utf8')
			self.ShowMessage(msg)
			return
		msg += _('Are you sure you want to update: ').decode('utf8')+vl+' '+sl+' --> '+vr+' '+sr+'?'
		if sr == 'stable': branch = 'stable'
		else: branch = 'beta'
		dlg = wx.MessageDialog(None, msg, _('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_EXCLAMATION)
		if dlg.ShowModal() == wx.ID_YES:
			subprocess.Popen(['lxterminal', '-e', 'bash', self.currentpath+'/update/update_OpenPlotter.sh', update_type, branch])
			dlg.Destroy()
			self.Close()
		else: dlg.Destroy()

	def default_desktop(self, e):
		subprocess.Popen(['lxterminal', '-e', 'bash', self.currentpath+'/update/default_openplotter_desk.sh'])
		self.ShowStatusBarBLACK(_('Follow the instructions of the new window'))

	def OnAboutBox(self, e):
		description = _(
			"OpenPlotter is a DIY, open-source, low-cost, low-consumption, modular and scalable sailing platform to run on ARM boards.")
		licence = """This program is free software: you can redistribute it
and/or modify it under the terms of the GNU General Public License
as published by the Free Software Foundation, either version 2 of
the License, or any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see http://www.gnu.org/licenses/"""

		info = wx.AboutDialogInfo()
		info.SetName('OpenPlotter')
		info.SetVersion(self.conf.get('GENERAL', 'version')+' '+self.conf.get('GENERAL', 'state'))
		info.SetDescription(description)
		info.SetCopyright('2018 Sailoog')
		info.SetWebSite('http://www.sailoog.com')
		info.SetLicence(licence)
		info.AddDeveloper(
			'sailoog\nhttps://github.com/sailoog\ne-sailing\nhttps://github.com/e-sailing\nseandepagnier\nhttps://github.com/seandepagnier\n')
		info.AddDocWriter('Gitbook\nhttps://docs.sailoog.com/openplotter-v1-x-x')
		info.AddTranslator('Crowdin\nhttps://crowdin.com/project/openplotter')
		wx.AboutBox(info)

	def op_doc(self, e):
		url = self.currentpath+"/docs/html/index.html"
		webbrowser.open(url, new=2)

	def Changingpage(self, e):
		self.ShowStatusBarBLACK('')

	def when_closed(self, e):
		self.nb.Destroy()
		sys.exit(0)

	def util_process_exist(self, process_name):
		pids = [pid for pid in os.listdir('/proc') if pid.isdigit()]
		exist = False
		for pid in pids:
			try:
				if process_name in open(os.path.join('/proc', pid, 'cmdline'), 'rb').read():
					exist = True
			except IOError:  # proc has already terminated
				continue
			if exist:
				break
		return exist

	###########################################Settings

	def page_startup(self):

		general = wx.StaticBox(self.p_startup, label=_('General'))

		self.op_maximize = wx.CheckBox(self.p_startup, label=_('Maximize OpenPlotter window'))

		self.disable_screensaver = wx.CheckBox(self.p_startup, label=_('Disable screen saver'))

		startup = wx.StaticBox(self.p_startup, label=_('Startup'))

		delay_label = wx.StaticText(self.p_startup, label=_('Delay (seconds)'))
		self.delay = wx.TextCtrl(self.p_startup)

		self.startup_opencpn = wx.CheckBox(self.p_startup, label='OpenCPN')
		self.startup_opencpn.Bind(wx.EVT_CHECKBOX, self.on_opencpn)
		self.startup_opencpn_nopengl = wx.CheckBox(self.p_startup, label=_('no OpenGL'))
		self.startup_opencpn_fullscreen = wx.CheckBox(self.p_startup, label=_('fullscreen'))

		self.startup_play_sound = wx.CheckBox(self.p_startup, label=_('Play sound'))
		self.startup_path_sound = wx.TextCtrl(self.p_startup)
		self.button_select_sound = wx.Button(self.p_startup, label=_('File'))
		self.button_select_sound.Bind(wx.EVT_BUTTON, self.on_select_sound)

		self.d800x480 = wx.CheckBox(self.p_startup, label=_('Check 800x480 display'))

		help_button = wx.BitmapButton(self.p_startup, bitmap=self.help_bmp, size=(self.help_bmp.GetWidth()+40, self.help_bmp.GetHeight()+10))
		help_button.Bind(wx.EVT_BUTTON, self.on_help_settngs)

		apply_changes = wx.Button(self.p_startup, label=_('Apply changes'))
		apply_changes.Bind(wx.EVT_BUTTON, self.on_apply_changes_settings)
		cancel_changes = wx.Button(self.p_startup, label=_('Cancel changes'))
		cancel_changes.Bind(wx.EVT_BUTTON, self.on_cancel_changes_settings)

		h_delay = wx.BoxSizer(wx.HORIZONTAL)
		h_delay.Add(delay_label, 0, wx.ALL, 5)
		h_delay.Add(self.delay, 0, wx.ALL, 5)

		h_opencpn = wx.BoxSizer(wx.HORIZONTAL)
		h_opencpn.Add(self.startup_opencpn, 0, wx.ALL, 5)
		h_opencpn.Add(self.startup_opencpn_fullscreen, 0, wx.ALL, 5)
		h_opencpn.Add(self.startup_opencpn_nopengl, 0, wx.ALL, 5)

		h_sound = wx.BoxSizer(wx.HORIZONTAL)
		h_sound.Add(self.startup_play_sound, 0, wx.ALL, 5)
		h_sound.Add(self.startup_path_sound, 1, wx.ALL | wx.EXPAND, 5)
		h_sound.Add(self.button_select_sound, 0, wx.ALL, 5)

		h_general = wx.BoxSizer(wx.HORIZONTAL)
		h_general.Add(self.op_maximize, 1, wx.ALL, 5)
		h_general.Add(self.disable_screensaver, 1, wx.ALL, 5)

		v_general = wx.StaticBoxSizer(general, wx.VERTICAL)
		v_general.AddSpacer(5)
		v_general.Add(h_general, 0, wx.ALL | wx.EXPAND, 0)
		v_general.AddSpacer(5)

		v_startup = wx.StaticBoxSizer(startup, wx.VERTICAL)
		v_startup.AddSpacer(5)
		v_startup.Add(h_delay, 0, wx.ALL, 0)
		v_startup.Add(h_opencpn, 0, wx.ALL, 0)
		v_startup.Add(h_sound, 0, wx.ALL | wx.EXPAND, 0)
		v_startup.Add(self.d800x480, 0, wx.ALL, 5)
		v_startup.AddSpacer(5)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(help_button, 0, wx.ALL, 0)
		hbox.Add((0, 0), 1, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(apply_changes, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(cancel_changes, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(v_general, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(v_startup, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add((0, 0), 1, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5)

		self.p_startup.SetSizer(vbox)

	def read_startup(self):
		self.delay.SetValue(self.conf.get('STARTUP', 'delay'))

		if self.conf.get('STARTUP', 'maximize') == '1':
			self.op_maximize.SetValue(True)
			self.Maximize()
		else: self.op_maximize.SetValue(False)

		if self.conf.get('STARTUP', 'screensaver') == '1': self.disable_screensaver.SetValue(True)
		else: self.disable_screensaver.SetValue(False)

		if self.conf.get('STARTUP', 'opencpn') == '1':
			self.startup_opencpn.SetValue(True)
			self.startup_opencpn_nopengl.Enable()
			self.startup_opencpn_fullscreen.Enable()
		else:
			self.startup_opencpn.SetValue(False)
			self.startup_opencpn_nopengl.Disable()
			self.startup_opencpn_fullscreen.Disable()
		if self.conf.get('STARTUP', 'opencpn_no_opengl') == '1': self.startup_opencpn_nopengl.SetValue(True)
		else: self.startup_opencpn_nopengl.SetValue(False)
		if self.conf.get('STARTUP', 'opencpn_fullscreen') == '1': self.startup_opencpn_fullscreen.SetValue(True)
		else: self.startup_opencpn_fullscreen.SetValue(False)

		if self.conf.get('STARTUP', '800x480') == '1': self.d800x480.SetValue(True)

		self.startup_path_sound.SetValue(self.conf.get('STARTUP', 'sound'))
		if self.conf.get('STARTUP', 'play') == '1': self.startup_play_sound.SetValue(True)
		else: self.startup_play_sound.SetValue(False)

	def on_opencpn(self, e):
		if self.startup_opencpn.GetValue():
			self.startup_opencpn_nopengl.Enable()
			self.startup_opencpn_fullscreen.Enable()
		else:
			self.startup_opencpn_nopengl.Disable()
			self.startup_opencpn_fullscreen.Disable()

	def on_select_sound(self, e):
		dlg = wx.FileDialog(self, message=_('Choose a file'), defaultDir=self.currentpath + '/sounds', defaultFile='',
							wildcard=_('Audio files').decode('utf8') + ' (*.mp3)|*.mp3|' + _('All files').decode('utf8') + ' (*.*)|*.*',
							style=wx.OPEN | wx.CHANGE_DIR)
		if dlg.ShowModal() == wx.ID_OK:
			file_path = dlg.GetPath()
			self.startup_path_sound.SetValue(file_path)
		dlg.Destroy()

	def on_apply_changes_settings(self, e):
		delay = self.delay.GetValue()
		if not delay: 
			self.delay.SetValue('0')
			delay = '0'
		try: float(delay)
		except:
			self.delay.SetValue('0')
			self.ShowStatusBarRED(_('You can enter only a number in Delay field.'))
			return
		self.conf.set('STARTUP', 'delay', delay)

		if self.op_maximize.GetValue(): 
			self.conf.set('STARTUP', 'maximize', '1')
			self.Maximize()
		else: self.conf.set('STARTUP', 'maximize', '0')

		if self.disable_screensaver.GetValue(): 
			self.conf.set('STARTUP', 'screensaver', '1')
			subprocess.call(['xset', 's', 'noblank'])
			subprocess.call(['xset', 's', 'off'])
			subprocess.call(['xset', '-dpms'])
		else: 
			self.conf.set('STARTUP', 'screensaver', '0')
			subprocess.call(['xset', 's', 'blank'])
			subprocess.call(['xset', 's', 'on'])
			subprocess.call(['xset', '+dpms'])

		if self.startup_opencpn.GetValue(): self.conf.set('STARTUP', 'opencpn', '1')
		else: self.conf.set('STARTUP', 'opencpn', '0')
		if self.startup_opencpn_nopengl.GetValue(): self.conf.set('STARTUP', 'opencpn_no_opengl', '1')
		else: self.conf.set('STARTUP', 'opencpn_no_opengl', '0')
		if self.startup_opencpn_fullscreen.GetValue(): self.conf.set('STARTUP', 'opencpn_fullscreen', '1')
		else: self.conf.set('STARTUP', 'opencpn_fullscreen', '0')

		if self.startup_play_sound.GetValue(): self.conf.set('STARTUP', 'play', '1')
		else: self.conf.set('STARTUP', 'play', '0')
		self.conf.set('STARTUP', 'sound', self.startup_path_sound.GetValue())

		if self.d800x480.GetValue(): self.conf.set('STARTUP', '800x480', '1')
		else: self.conf.set('STARTUP', '800x480', '0')

		self.ShowStatusBarGREEN(_('Settings changes saved'))

	def on_cancel_changes_settings(self, e):
		self.read_startup()

	def on_help_settngs(self, e):
		url = self.currentpath+"/docs/html/getting_started/settings.html"
		webbrowser.open(url, new=2)

	###########################################dashboards

	def page_dashboards(self):
		instrumentpanel = wx.StaticBox(self.p_dashboards, label=_('Instrument Panel'))
		button_instrumentpanel = wx.Button(self.p_dashboards, label=_('Edit/Show'))
		button_instrumentpanel.Bind(wx.EVT_BUTTON, self.on_instrumentpanel)

		kip = wx.StaticBox(self.p_dashboards, label=_('KIP'))
		button_kip = wx.Button(self.p_dashboards, label=_('Edit/Show'))
		button_kip.Bind(wx.EVT_BUTTON, self.on_kip)

		nodered = wx.StaticBox(self.p_dashboards, label=_('Node-Red Dashboard'))
		button_edit_nodered = wx.Button(self.p_dashboards, label=_('Edit'))
		button_edit_nodered.Bind(wx.EVT_BUTTON, self.on_edit_nodered)
		button_show_nodered = wx.Button(self.p_dashboards, label=_('Show'))
		button_show_nodered.Bind(wx.EVT_BUTTON, self.on_show_nodered)

		influxgrafana = wx.StaticBox(self.p_dashboards, label=_('Influxdb + Grafana'))
		self.enable_influxgrafana = wx.CheckBox(self.p_dashboards, label=_('Create database "boatdata"'))
		retencion_label = wx.StaticText(self.p_dashboards, label=_('Retencion time'))
		self.retencion_time = wx.TextCtrl(self.p_dashboards)
		retencion_units = [_('hour'),_('day'),_('week')]
		self.retencion_units2 = ['h','d','w']
		self.retencion_unit = wx.ComboBox(self.p_dashboards, choices=retencion_units, style=wx.CB_READONLY)
		button_edit_influxgrafana = wx.Button(self.p_dashboards, label=_('Add Signal K paths'))
		button_edit_influxgrafana.Bind(wx.EVT_BUTTON, self.on_edit_influxgrafana)
		button_show_influxgrafana = wx.Button(self.p_dashboards, label=_('Edit/Show'))
		button_show_influxgrafana.Bind(wx.EVT_BUTTON, self.on_show_influxgrafana)

		help_button = wx.BitmapButton(self.p_dashboards, bitmap=self.help_bmp, size=(self.help_bmp.GetWidth()+40, self.help_bmp.GetHeight()+10))
		help_button.Bind(wx.EVT_BUTTON, self.on_help_dashboards)

		apply_changes = wx.Button(self.p_dashboards, label=_('Apply changes'))
		apply_changes.Bind(wx.EVT_BUTTON, self.on_apply_changes_dashboards)
		cancel_changes = wx.Button(self.p_dashboards, label=_('Cancel changes'))
		cancel_changes.Bind(wx.EVT_BUTTON, self.on_cancel_changes_dashboards)

		h_instrumentpanel = wx.StaticBoxSizer(instrumentpanel, wx.HORIZONTAL)
		h_instrumentpanel.Add(button_instrumentpanel, 0, wx.ALL, 10)

		h_kip = wx.StaticBoxSizer(kip, wx.HORIZONTAL)
		h_kip.Add(button_kip, 0, wx.ALL, 10)

		h_nodered = wx.StaticBoxSizer(nodered, wx.HORIZONTAL)
		h_nodered.Add(button_edit_nodered, 0, wx.ALL, 10)
		h_nodered.Add(button_show_nodered, 0, wx.ALL, 10)

		h_influxgrafana = wx.BoxSizer(wx.HORIZONTAL)
		h_influxgrafana.Add(retencion_label, 0, wx.TOP | wx.BOTTOM, 6)
		h_influxgrafana.Add(self.retencion_time, 0, wx.LEFT | wx.RIGHT, 5)
		h_influxgrafana.Add(self.retencion_unit, 0, wx.ALL, 0)

		h2_influxgrafana = wx.BoxSizer(wx.HORIZONTAL)
		h2_influxgrafana.Add(button_edit_influxgrafana, 0, wx.ALL, 10)
		h2_influxgrafana.Add(button_show_influxgrafana, 0, wx.ALL, 10)

		v_influxgrafana = wx.StaticBoxSizer(influxgrafana, wx.VERTICAL)
		v_influxgrafana.Add(self.enable_influxgrafana, 0, wx.ALL, 10)
		v_influxgrafana.Add(h_influxgrafana, 0, wx.LEFT | wx.RIGHT, 10)
		v_influxgrafana.Add(h2_influxgrafana, 0, wx.ALL, 0)

		vleft = wx.BoxSizer(wx.VERTICAL)
		vleft.AddSpacer(5)
		vleft.Add(h_instrumentpanel, 0, wx.ALL | wx.EXPAND, 0)
		vleft.AddSpacer(10)
		vleft.Add(h_kip, 0, wx.ALL | wx.EXPAND, 0)
		vleft.AddSpacer(10)
		vleft.Add(h_nodered, 0, wx.ALL | wx.EXPAND, 0)

		vright = wx.BoxSizer(wx.VERTICAL)
		vright.AddSpacer(5)
		vright.Add(v_influxgrafana, 0, wx.ALL | wx.EXPAND, 0)

		hboth = wx.BoxSizer(wx.HORIZONTAL)
		hboth.Add(vleft, 1, wx.ALL | wx.EXPAND, 5)
		hboth.Add(vright, 1, wx.ALL | wx.EXPAND, 5)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(help_button, 0, wx.ALL, 0)
		hbox.AddStretchSpacer(1)
		hbox.Add(apply_changes, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(cancel_changes, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(hboth, 0, wx.ALL | wx.EXPAND, 0)
		vbox.AddStretchSpacer(1)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5)

		self.p_dashboards.SetSizer(vbox)

	def read_dashboards(self):
		if self.conf.get('DASHBOARDS', 'database') == '1': self.enable_influxgrafana.SetValue(True)
		else: self.enable_influxgrafana.SetValue(False)
		self.retencion_time.SetValue(self.conf.get('DASHBOARDS', 'retencion_time'))
		unit = self.conf.get('DASHBOARDS', 'retencion_unit')
		for index, item in enumerate(self.retencion_units2):
			if item == unit: self.retencion_unit.SetSelection(index)

	def on_instrumentpanel(self, e):
		url = "http://openplotter.local:3000/@signalk/instrumentpanel/"
		webbrowser.open(url, new=2)

	def on_kip(self, e):
		url = "http://openplotter.local:3000/@mxtommy/kip/"
		webbrowser.open(url, new=2)

	def on_edit_nodered(self, e):
		url = "http://openplotter.local:3000/plugins/signalk-node-red/redAdmin/"
		webbrowser.open(url, new=2)

	def on_show_nodered(self, e):
		url = "http://openplotter.local:3000/plugins/signalk-node-red/redApi/ui/"
		webbrowser.open(url, new=2)

	def on_edit_influxgrafana(self, e):
		url = "http://openplotter.local:3000/admin/#/serverConfiguration/plugins/signalk-to-influxdb"
		webbrowser.open(url, new=2)

	def on_show_influxgrafana(self, e):
		url = "http://openplotter.local:3001"
		webbrowser.open(url, new=2)

	def on_apply_changes_dashboards(self, e):
		try: rtime = int(self.retencion_time.GetValue())
		except:
			self.ShowStatusBarRED(_('Retencion time must be an integer'))
			return
		selection = self.retencion_unit.GetSelection()
		if selection == -1:
			self.ShowStatusBarRED(_('Select a retencion time unit'))
			return
		runit = self.retencion_units2[selection]
		if self.enable_influxgrafana.GetValue():
			self.ShowStatusBarRED(_('Creating database and starting Influxdb/Grafana services... '))
			subprocess.call(['sudo', 'systemctl', 'unmask', 'influxdb.service'])
			subprocess.call(['sudo', 'systemctl', 'enable', 'influxdb.service'])
			subprocess.call(['sudo', 'systemctl', 'start', 'influxdb'])
			subprocess.call(['sudo', 'systemctl', 'enable', 'grafana-server.service'])
			subprocess.call(['sudo', 'systemctl', 'start', 'grafana-server'])
			self.conf.set('DASHBOARDS', 'database', '1')
			seconds = 20
			for i in range(seconds, 0, -1):
				self.ShowStatusBarRED(_('Creating database and starting Influxdb/Grafana services... ')+str(i))
				time.sleep(1)
			subprocess.call(['bash', self.currentpath+'/classes/influxdb_set.sh', 'y', str(rtime)+str(runit)])
		else:
			self.ShowStatusBarRED(_('Removing database and stopping Influxdb/Grafana services'))
			subprocess.call(['bash', self.currentpath+'/classes/influxdb_set.sh', 'n', str(rtime)+str(runit)])
			subprocess.call(['sudo', 'systemctl', 'disable', 'influxdb.service'])
			subprocess.call(['sudo', 'systemctl', 'stop', 'influxdb'])
			subprocess.call(['sudo', 'systemctl', 'disable', 'grafana-server.service'])
			subprocess.call(['sudo', 'systemctl', 'stop', 'grafana-server'])
			self.conf.set('DASHBOARDS', 'database', '0')
		self.conf.set('DASHBOARDS', 'retencion_time', str(rtime))
		self.conf.set('DASHBOARDS', 'retencion_unit', str(runit))
		self.ShowStatusBarGREEN(_('Dashboards changes saved'))

	def on_cancel_changes_dashboards(self, e):
		self.read_dashboards()

	def on_help_dashboards(self, e):
		url = self.currentpath+"/docs/html/dashboards/what_are_dashboards.html"
		webbrowser.open(url, new=2)

	###########################################Network

	def page_wifi(self):
		modelfile = open('/sys/firmware/devicetree/base/model', 'r', 2000)
		self.rpimodel = modelfile.read()
		modelfile.close()
			
		leftbox = wx.StaticBox(self.p_wifi, label=_('Network mode')+'  '+self.rpimodel)
	
		self.available_share = []
		self.available_ap_device2 = []

		self.ap_device_label = wx.StaticText(self.p_wifi, label=_('AP'))
		self.ap_device = wx.ComboBox(self.p_wifi, choices=self.available_ap_device2, style=wx.CB_READONLY, size=(265, -1))
		self.ap_device.Bind(wx.EVT_COMBOBOX, self.on_ap_device)

		h_ap = wx.BoxSizer(wx.HORIZONTAL)
		h_ap.Add(self.ap_device_label, 0, wx.TOP | wx.BOTTOM, 6)
		h_ap.Add(self.ap_device, 0, wx.LEFT, 5)	
		#h_ap.Add(self.ap_device_label, 0, wx.RIGHT | wx.UP |wx.EXPAND, 10)
		#h_ap.Add(self.ap_device, 0, wx.RIGHT | wx.EXPAND, 10)	
		
		self.ap_5 = wx.CheckBox(self.p_wifi, label=_('5 GHz'))
		self.bridge = wx.CheckBox(self.p_wifi, label=_('Add ethernet port to the AP'))
		
		h_set = wx.BoxSizer(wx.HORIZONTAL)
		h_set.Add(self.ap_5, 0, wx.TOP | wx.BOTTOM | wx.EXPAND, 6)
		h_set.AddSpacer(10)
		h_set.Add(self.bridge, 0, wx.TOP | wx.BOTTOM | wx.EXPAND, 6)

		self.wifi_button_apply1 = wx.Button(self.p_wifi, label=_('Apply')+' 1')
		self.wifi_button_apply1.Bind(wx.EVT_BUTTON, self.on_wifi_apply1)		

		self.drivers_button = wx.Button(self.p_wifi, label=_('Install drivers'))
		self.drivers_button.Bind(wx.EVT_BUTTON, self.on_drivers_button)			
		
		h_button0 = wx.BoxSizer(wx.HORIZONTAL)
		h_button0.Add(self.wifi_button_apply1, 0, wx.EXPAND, 0)
		h_button0.AddStretchSpacer(1)
		h_button0.Add(self.drivers_button, 0, wx.EXPAND, 0)

		v_leftbox = wx.StaticBoxSizer(leftbox, wx.VERTICAL)
		v_leftbox.AddSpacer(5)
		v_leftbox.Add(h_ap, 0, wx.LEFT, 10)
		v_leftbox.Add(h_set, 0, wx.LEFT | wx.EXPAND, 8)
		v_leftbox.Add(h_button0, 0, wx.LEFT |wx.RIGHT | wx.EXPAND, 10)
		v_leftbox.AddSpacer(6)
		
		leftbox2 = wx.StaticBox(self.p_wifi, label=_('Access point settings'))

		self.share = wx.ComboBox(self.p_wifi, choices=self.available_share, style=wx.CB_READONLY, size=(120, -1))
		self.share.Bind(wx.EVT_COMBOBOX, self.on_share)
		self.share_label = wx.StaticText(self.p_wifi, label=_('Sharing Internet device'))

		h_share = wx.BoxSizer(wx.HORIZONTAL)
		h_share.Add(self.share, 0)
		h_share.AddSpacer(5)
		h_share.Add(self.share_label, 0, wx.TOP | wx.BOTTOM, 5)
		
		self.ssid = wx.TextCtrl(self.p_wifi, -1, size=(120, -1))
		self.ssid_label = wx.StaticText(self.p_wifi, label=_('SSID \nmaximum 32 characters'))

		h_ssid = wx.BoxSizer(wx.HORIZONTAL)
		h_ssid.Add(self.ssid, 0)
		h_ssid.AddSpacer(5)
		h_ssid.Add(self.ssid_label, 0)

		self.passw = wx.TextCtrl(self.p_wifi, -1, size=(120, -1))
		self.passw_label = wx.StaticText(self.p_wifi, label=_('Password \nminimum 8 characters required'))
		
		h_passw = wx.BoxSizer(wx.HORIZONTAL)
		h_passw.Add(self.passw, 0)
		#h_passw.Add(self.passw, 0, wx.TOP | wx.BOTTOM, 1)
		h_passw.AddSpacer(5)
		h_passw.Add(self.passw_label, 0)
		
		self.wifi_channel_list = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13','36','40','44','48','149','153','157','161','165']
		self.wifi_channel = wx.ComboBox(self.p_wifi, choices=self.wifi_channel_list, style=wx.CB_READONLY, size=(120, -1))
		self.wifi_channel_label = wx.StaticText(self.p_wifi, label=_('Channel'))

		h_wifi_channel = wx.BoxSizer(wx.HORIZONTAL)
		h_wifi_channel.Add(self.wifi_channel, 0)
		h_wifi_channel.AddSpacer(5)
		h_wifi_channel.Add(self.wifi_channel_label, 0, wx.TOP | wx.BOTTOM, 6)

		self.wifi_button_apply = wx.Button(self.p_wifi, label=_('Apply')+' 2')
		self.wifi_button_apply.Bind(wx.EVT_BUTTON, self.on_wifi_apply2)

		h_button = wx.BoxSizer(wx.HORIZONTAL)
		h_button.Add(self.wifi_button_apply, 0, wx.Left, 10)

		v_leftbox2 = wx.StaticBoxSizer(leftbox2, wx.VERTICAL)
		v_leftbox2.AddSpacer(5)
		v_leftbox2.Add(h_share, 0, wx.LEFT | wx.EXPAND, 10)
		v_leftbox2.AddSpacer(5)
		v_leftbox2.Add(h_ssid, 0, wx.LEFT | wx.EXPAND, 10)
		v_leftbox2.AddSpacer(3)
		v_leftbox2.Add(h_passw, 0, wx.LEFT | wx.EXPAND, 10)
		v_leftbox2.AddSpacer(3)
		v_leftbox2.Add(h_wifi_channel, 0, wx.LEFT | wx.EXPAND, 10)
		v_leftbox2.AddStretchSpacer(1)
		v_leftbox2.Add(h_button, 0, wx.LEFT | wx.EXPAND, 10)
		v_leftbox2.AddSpacer(6)
		
		v_leftside = wx.BoxSizer(wx.VERTICAL)
		v_leftside.Add(v_leftbox, 0, wx.LEFT | wx.EXPAND, 10)
		v_leftside.AddSpacer(5)		
		v_leftside.Add(v_leftbox2, 1, wx.LEFT | wx.EXPAND, 10)

		
		rigthbox = wx.StaticBox(self.p_wifi, label=_(' Addresses '), size=(290, -1))
		self.ip_info = wx.TextCtrl(self.p_wifi, -1, style=wx.TE_MULTILINE | wx.TE_READONLY)
		self.ip_info.SetBackgroundColour(wx.SystemSettings_GetColour(wx.SYS_COLOUR_INACTIVECAPTION))

		self.button_refresh_ip_info = wx.Button(self.p_wifi, label=_('Refresh'))
		self.button_refresh_ip_info.Bind(wx.EVT_BUTTON, self.on_refresh_ip_info)

		self.button_net_status = wx.Button(self.p_wifi, label=_('Status'))
		self.button_net_status.Bind(wx.EVT_BUTTON, self.on_net_status)

		h_rbutton = wx.BoxSizer(wx.HORIZONTAL)
		h_rbutton.Add(self.button_refresh_ip_info, 0, wx.RIGHT | wx.EXPAND, 10)
		h_rbutton.Add(self.button_net_status, 0, wx.RIGHT | wx.EXPAND, 10)

		v_rigthbox = wx.StaticBoxSizer(rigthbox, wx.VERTICAL)	
		v_rigthbox.AddSpacer(5)		
		v_rigthbox.Add(self.ip_info, 1, wx.LEFT | wx.EXPAND, 10)
		v_rigthbox.AddSpacer(6)		
		v_rigthbox.Add(h_rbutton, 0, wx.LEFT | wx.EXPAND, 10)
		v_rigthbox.AddSpacer(6)


		h_box = wx.BoxSizer(wx.HORIZONTAL)
		h_box.Add(v_leftside, 1, wx.ALL | wx.EXPAND, 5)
		h_box.Add(v_rigthbox, 0, wx.ALL | wx.EXPAND, 5)
		
		v_box = wx.BoxSizer(wx.VERTICAL)
		v_box.Add(h_box, 1, wx.LEFT | wx.EXPAND, 0)
		
		self.p_wifi.SetSizer(v_box)		
		
	def find_line_split_set(self,data,search,_setvalue,pos):
		i=data.find(search)
		if i>=0:
			j=data[i:].find("\n")
			if j==0:j=data[i:].length
			line = data[i:i+j]
			sline = line.split('=')
			if len(sline)>1:
				_setvalue.SetValue(sline[pos])
	
	def find_line_split(self,data,search,pos):
		i=data.find(search)
		if i>=0:
			j=data[i:].find("\n")
			if j==0:j=data[i:].length
			line = data[i:i+j]
			sline = line.split('=')
			if len(sline)>1:
				return sline[pos]
			else:
				return ""

	def read_network_interfaces(self):
		network_info = ''
		try:
			network_info = subprocess.check_output('ls /sys/class/net'.split())
		except:
			pass

		self.available_share = [_('none')]
		unavailable_net = ['uap0','wlan1','lo']
		if self.bridge.GetValue():
			unavailable_net.append('eth0')

		for i in network_info.split():		
			if i in unavailable_net:
				pass
			else:
				self.available_share.append(i)

		self.share.Clear()
		for i in self.available_share:
			self.share.Append(i)				
		
		type=''
		phy=''
		AP=-1
		GHz=-1
		
		self.available_ap_device = []
		self.available_ap_device.append([_('none'),'',-1,-1,'none'])
		for i in network_info.split():
			if 'wlan' in i:
				wlan = 'wlan1'
				mac = (subprocess.check_output(('cat /sys/class/net/'+i+'/address').split())[:-1])
				if 'usb' in subprocess.check_output(('ls -l /sys/class/net/'+i).split()):
					type  = 'usb'
					ni = subprocess.check_output(('ls -l /sys/class/net/'+i+'/').split())
					phy = ni[ni.find('/phy')+1:ni.find('/phy')+5]
					ni = subprocess.check_output(('iw '+phy+' info').split())
					AP = ni.find('* AP\n')
					GHz = ni.find('Band 2:')
					if AP > -1:
						self.available_ap_device.append([mac+' '+type, mac, type, GHz, wlan])
				else:
					type = 'on board'
					if 'Raspberry Pi 3 Model B Plus' in self.rpimodel:
						GHz = 1
					else:
						GHz = -1
					self.available_ap_device.append([mac+' '+type, mac, type, GHz, wlan])

		if 'Raspberry Pi 3 Model B R' in self.rpimodel and len(self.available_ap_device) == 2:
			for i in self.available_ap_device:
				if 'on board' == i[2]:
					type = 'AP and Station'
					wlan = 'uap0'
					self.available_ap_device.append([i[1]+' '+type, i[1], type, i[3], wlan])

		self.available_ap_device2 = []
		for i in self.available_ap_device:
			self.available_ap_device2.append(i[0])
			
		self.ap_device.Clear()
		for i in self.available_ap_device2:
			self.ap_device.Append(i)

	def read_wifi_conf(self):
		self.conf_network = self.conf_folder + '/Network'
		self.bak_net_sys = ''

		if os.path.isdir(self.conf_network):
			self.bak_net_sys = os.listdir(self.conf_network)
			if len(self.bak_net_sys)>0: 
				self.bak_net_sys = self.bak_net_sys[0]
			else:
				self.bak_net_sys = ''
		
		self.bak_passw=''
		self.bak_share=''
		self.hostapd_interface=''
		self.hostapd_bridge=''
		if self.bak_net_sys<>'' and self.bak_net_sys<>'default':
			self.ap_enable2()
		
			#read settings from hostapd.conf  GHz, bridge, ssid, password, channel
			try:
				wififile = open(self.conf_network+'/hostapd/hostapd.conf', 'r', 2000)
				bak = wififile.read()
				wififile.close()
			except:
				bak=''
			if len(bak)>0:
				self.find_line_split_set(bak,"wpa_passphrase",self.passw,1)
				self.bak_passw=self.passw.GetValue()
				if len(self.bak_passw) > 0:
					self.passw.SetValue('**********')
				self.find_line_split_set(bak,"ssid",self.ssid,1)
				self.hostapd_interface = self.find_line_split(bak,"interface",1)
				if (self.find_line_split(bak,"hw_mode",1))[0:1] == "a":
					self.ap_5.SetValue(True)
					self.wifi_channel_list = ['36','40','44','48','149','153','157','161','165']
				else:
					self.ap_5.SetValue(False)
					self.wifi_channel_list = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13']
				
				self.wifi_channel.Clear()
				for i in self.wifi_channel_list:
					self.wifi_channel.Append(i)				
				self.find_line_split_set(bak,"channel",self.wifi_channel,1)
				
				i=bak.find("bridge=br0")
				if i>=0:
					i=bak.find("#bridge=br0")
					if i>=0:
						self.bridge.SetValue(False)
					else:
						self.bridge.SetValue(True)
			self.read_network_interfaces()

			#search selected AP device 
			found = False
			if 'uap0' == self.hostapd_interface:
				for i in self.available_ap_device:
					if 'AP and Station' == i[2]:
						self.ap_device.SetStringSelection(i[0])
						self.ap_5.Disable()
						if i[3]>=1: self.ap_5.Enable()
						found = True;
			else:
				try:
					wififile = open(self.conf_network+'/udev/rules.d/72-wireless.rules', 'r', 2000)
					bak = wififile.read()
					wififile.close()
				except:
					bak=''
				if 'brcmfmac' in bak:
					for i in self.available_ap_device:
						if 'on board' == i[2]:
							self.ap_device.SetStringSelection(i[0])
							self.ap_5.Disable()
							if i[3]>=1: self.ap_5.Enable()
							found = True;
				if not found:
					for i in self.available_ap_device:
						if i[1] in bak and len(i[1])>10:
							self.ap_device.SetStringSelection(i[0])
							self.ap_5.Disable()
							if i[3]>=1: self.ap_5.Enable()
							found = True;
			if not found:
				self.ap_device.SetStringSelection(_('none'))
				self.ap_disable()
			else:
				self.ap_enable()
			
			#search shared device from iptables.sh
			
			i=' '
			try:
				wififile = open(self.conf_network+'/../start-ap-managed-wifi.sh', 'r', 2000)
				bak = wififile.read()
				wififile.close()
			except:
				bak=''
			i=self.find_line_split(bak,"internet=",1)
			if i<>None:
				if i in self.available_share:
					pass
				else: self.share.Append(i)
				self.share.SetValue(i)
			else:
				self.share.SetValue(_('none'))
			
		else:
			self.ap_disable()
			self.read_network_interfaces()


		for i in self.available_ap_device:
			if i[0] == self.bak_net_sys:
				self.ap_device.SetValue(i[1])
		self.on_refresh_ip_info('')

	def ap_disable(self):
		self.ap_5.Disable()
		self.bridge.Disable()

		self.ap_5.SetValue(False)
		self.bridge.SetValue(False)
		
		self.share.Disable()
		self.ssid.Disable()
		self.passw.Disable()
		self.wifi_channel.Disable()
		
		self.wifi_channel.SetValue('')
		self.passw.SetValue('')
		self.ssid.SetValue('')
		self.share.SetValue('')
	
	def ap_enable(self):
		self.bridge.Enable()
		
	def ap_enable2(self):
		self.share.Enable()
		self.ssid.Enable()
		self.passw.Enable()
		self.wifi_channel.Enable()
	
	def on_ap_device(self, e):
		j = self.ap_device.GetValue()
		self.ap_enable()
		self.ap_5.Disable()
		for i in self.available_ap_device:
			if _('none') == j:
				self.ap_disable()
			if i[0] == j:
				if i[3] >0:
					self.ap_5.Enable()

	def on_wifi_apply1(self, e):
		self.ShowStatusBarBLACK(_('wait'))
		j = self.ap_device.GetValue()
		for i in self.available_ap_device:
			if i[0] == j:
				if self.bridge.GetValue():
					text = 'br0'
				else:
					text = 'no'
				text += ' '+i[4]+' '+i[1]+' '
				if self.ap_5.GetValue():
					text += '5'
				else:
					text += '2.4'
				if i[2] == 'usb':
					text += ' e'
				else:
					text += ' i'
				process = subprocess.Popen(('bash '+self.currentpath+'/Network/copy_main.sh '+text).split())
				time.sleep(2)
		self.read_wifi_conf()
		self.ShowStatusBarBLACK('')

	def on_drivers_button(self,e):
		subprocess.Popen(['lxterminal', '-e', 'bash', self.currentpath+'/classes/install-wifi.sh'])	

	#leftbox 2
	def on_share(self, e):
		share = self.share.GetValue()
		
		dlg = wx.MessageDialog(None, _(
			'Do you want to change the internet connection directly?'),
			_('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
		if dlg.ShowModal() != wx.ID_YES:
			dlg.Destroy()
			return
		
		j = self.ap_device.GetValue()
		for i in self.available_ap_device:
			if i[0] == j:
				text = i[4]
				if self.bridge.GetValue():
					text = 'br0'
		process = subprocess.Popen(['bash', self.currentpath+'/Network/.openplotter/iptables.sh',share,text])

	def on_wifi_apply2(self, e):
		if 'none' <> self.ap_device.GetValue():
			if '*****' in self.passw.GetValue():
				passw = self.bak_passw
			else:
				passw = self.passw.GetValue()
				
			ssid = self.ssid.GetValue()
			channel = self.wifi_channel.GetValue()
			share = self.share.GetValue()
			
			if self.bak_net_sys<>'' and self.bak_net_sys<>'default':
				if (len(ssid) > 32 or len(passw) < 8):
					self.ShowStatusBarRED(_('Your SSID must have a maximum of 32 characters and your password a minimum of 8.'))
					return

			used_interfaces=[self.hostapd_interface]
			if self.hostapd_bridge<>'':
				used_interfaces.append('eth0')
			if share in used_interfaces:
				self.ShowStatusBarRED(_('The device you want to share is in use (bridge or AP).'))
				return
								
			dlg = wx.MessageDialog(None, _(
				'Changes will be applied after next reboot.\n\nIf something goes wrong and you are on a headless system,\nyou may not be able to reconnect again.\n\nAre you sure?'),
				_('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
			if dlg.ShowModal() != wx.ID_YES:
				dlg.Destroy()
				return
			
			if os.path.isfile(self.conf_network+'/'+self.bak_net_sys+'/hostapd/hostapd.conf'):
				wififile = open(self.conf_network+'/'+self.bak_net_sys+'/hostapd/hostapd.conf', 'r', 2000)
				lines = wififile.readlines()
				wififile.close()
				
				wififile = open(self.conf_network+'/'+self.bak_net_sys+'/hostapd/hostapd.conf', 'w')
				for line in lines:
					if 0<=line.find("wpa_passphrase"): line = "wpa_passphrase="+passw+'\n'
					if 0<=line.find("channel"): line = "channel="+channel+'\n'
					if 0<=line.find("ssid"): 
						sline = line.split('=')
						if sline[0][:4]== "ssid":
							line = "ssid="+ssid+'\n'
					wififile.write(line)
				wififile.close()
			
			if os.path.isfile(self.conf_network+'/'+self.bak_net_sys+'/.openplotter/Network/start-ap-managed-wifi.sh'):
				if self.bak_share<>share:
					wififile = open(self.conf_network+'/'+self.bak_net_sys+'/.openplotter/Network/start-ap-managed-wifi.sh', 'r', 2000)
					lines = wififile.readlines()
					wififile.close()

					wififile = open(self.conf_network+'/'+self.bak_net_sys+'/.openplotter/Network/start-ap-managed-wifi.sh', 'w')
					for line in lines:
						if 0<=line.find("internet="): line = "internet="+share
						wififile.write(line)
					wififile.close()
			process = subprocess.Popen(['bash', self.currentpath+'/Network/install.sh'], cwd = self.conf_network)
		else:
			process = subprocess.Popen(['bash', self.currentpath+'/Network/install.sh','uninstall'], cwd = self.conf_network)
	
	#rightbox
	def on_show_ip_info_txt(self,port,ips,ip_hostname):
		out='   '+ip_hostname + '.local:'+port+'\n'
		if port != '':
			port=':'+port
		for ip in ips:
			if ip[0:7]=='169.254':
				pass
			elif ':' in ip:
				pass
			else:
				out +='   '+ ip + port+'\n'
		return out		
			
	def on_refresh_ip_info(self, e):
		ip_hostname = subprocess.check_output(['hostname'])[:-1]
		ip_info = subprocess.check_output(['hostname', '-I'])
		out = _(' Multiplexed NMEA 0183:\n')
		ips = ip_info.split()		
		out += self.on_show_ip_info_txt('10110',ips,ip_hostname)
		out += _('\n Signal K Server:\n')
		out += self.on_show_ip_info_txt('3000',ips,ip_hostname)
		out += _('\n VNC remote desktop:\n')
		out += self.on_show_ip_info_txt('5900',ips,ip_hostname)
		out += _('\n grafana:\n')
		out += self.on_show_ip_info_txt('3001',ips,ip_hostname)
		out += _('\n MQTT local broker:\n')
		out += self.on_show_ip_info_txt('1883',ips,ip_hostname)
		self.ip_info.SetValue(out)

	def on_net_status(self, e):
		msg = ''
		msg1 = ''

		wlan_interfaces=['wlan0','wlan1','uap0']
		
		for i in wlan_interfaces:
			network_info = ''
			try:
				network_info = subprocess.check_output(('iw '+str(i)+' info').split())
			except:
				pass
			if 'AP' in network_info: msg1 += str(i)+_(' is AP')
		if msg1 == '': msg1 += _('no AP')
		msg += msg1 + '\n'

		msg1 = ''
		network_info = ''
		try:
			network_info = subprocess.check_output('ifconfig'.split())
		except:
			pass
		net=['wlan0','wlan1','uap0','usb0','br0','eth0','eth1']
		netactiv = [False,False,False,False,False,False,False]

		for i in network_info.split('\n'):
			for j in range(7):
				if net[j] in i: 
					netactiv[j]=True
					if j<3: msg1 += net[j]+' '
		msg += _('up network: ') + msg1 + '\n'

		service=['dnsmasq','hostapd','dhcpcd','avahi-daemon']
		servicetxt=['dnsmasq (dhcp-server):\t','hostapd (AP):\t\t\t','dhcpcd:\t\t\t\t\t','avahi-daemon:\t\t\t']

		for j in range(len(service)):
			msg1 = ''
			network_info = ''
			try:
				network_info = subprocess.check_output(('service '+service[j]+' status').split())
			except:
				pass
			for i in network_info.split('\n'):
				if '(running)' in i: msg1 += _('running')
			if msg1 == '': msg1 += _('stopped')
			msg += servicetxt[j] + msg1 + '\n'

		msg1 = ''
		network_info = ''

		for j in range(7):
			if netactiv[j]:
				network_info = subprocess.check_output(('ip addr show '+net[j]).split())
				for i in network_info.split('\n'):
					if 'inet ' in i:
						if not '169.254' in i.split(' ')[5]: 
							msg1 += i.split(' ')[5][0:-3] + ' ' + net[j] + '\n'
				network_info = ''
		msg += _('IP address\n') + msg1 + '\n'

		self.ShowMessage(msg)

	###########################################pypiloy

	def page_pypilot(self):
		pypilot_mode_label = wx.StaticText(self.p_pypilot, label=_('pypilot Mode:'))
		self.pypilot_modes = ['disabled', 'imu', 'basic autopilot'] # nontranslated for config
		self.pypilot_mode = wx.Choice(self.p_pypilot, choices=[_('disabled'), _('IMU only'), _('basic autopilot')], style=wx.CB_READONLY)
		self.pypilot_mode.Bind(wx.EVT_CHOICE, self.select_pypilot)

		imu_box = wx.StaticBox(self.p_pypilot, label=_(' IMU '))
		detected_label = wx.StaticText(self.p_pypilot, label=_('Detected IMU:'))
		self.imu_detected = wx.StaticText(self.p_pypilot, label=_('None'))

		self.reset_imu = wx.Button(self.p_pypilot, label=_('Reset'))
		self.reset_imu.Bind(wx.EVT_BUTTON, self.on_pypilot_reset)

		connections_box = wx.StaticBox(self.p_pypilot, label= _(' Autopilot '))

		serial_ports_label = wx.StaticText(self.p_pypilot, label=_('Serial ports (Controller/Wind/GPS)'))
		self.pypilot_nmea = wx.TextCtrl(self.p_pypilot,style=wx.TE_MULTILINE | wx.VSCROLL | wx.TE_READONLY)

		self.pypilot_webapp_cb = wx.CheckBox(self.p_pypilot, False, _('Enable webapp'))
		pypilot_webapp_port_label = wx.StaticText(self.p_pypilot, label=_('port:'))
		self.pypilot_webapp_port = wx.SpinCtrl(self.p_pypilot, min=1, max=65536, initial=8080)

		self.calibration = wx.Button(self.p_pypilot, label=_('Calibration'))
		self.calibration.Bind(wx.EVT_BUTTON, self.on_pypilot_calibration)

		self.scope = wx.Button(self.p_pypilot, label=_('Scope'))
		self.scope.Bind(wx.EVT_BUTTON, self.on_pypilot_scope)

		self.client = wx.Button(self.p_pypilot, label=_('Client'))
		self.client.Bind(wx.EVT_BUTTON, self.on_pypilot_client)

		self.pypilot_control = wx.Button(self.p_pypilot, label=_('Autopilot Control'))
		self.pypilot_control.Bind(wx.EVT_BUTTON, self.on_pypilot_control)

		restart = wx.Button(self.p_pypilot, label=_('Restart'))
		restart.Bind(wx.EVT_BUTTON, self.reset_sensors)

		apply_changes_pypilot = wx.Button(self.p_pypilot, label=_('Apply changes'))
		apply_changes_pypilot.Bind(wx.EVT_BUTTON, self.on_apply_changes_pypilot)
		cancel_changes_pypilot = wx.Button(self.p_pypilot, label=_('Cancel changes'))
		cancel_changes_pypilot.Bind(wx.EVT_BUTTON, self.on_cancel_changes_pypilot)

		self.pypilot_translation_names_list = ['magnetic_h', 'attitude']
		translation_choices = ['imu.heading -> navigation.headingMagnetic','imu.[pitch, roll] -> navigation.attitude.[pitch, roll]']
		self.pypilot_signalk_translation = wx.CheckListBox(self.p_pypilot, choices=translation_choices)

		translation_rate_label = wx.StaticText(self.p_pypilot, label=_('Translation Rate (seconds)'))
		translation_rate_list = ['0.1', '0.2', '0.5', '1', '2', '5', '10', '30', '60']
		self.pypilot_translation_rate= wx.Choice(self.p_pypilot, choices=translation_rate_list)

		diagnostic = wx.Button(self.p_pypilot, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		hbox1 = wx.BoxSizer(wx.HORIZONTAL)
		hbox1.Add(pypilot_mode_label, 0, wx.TOP | wx.BOTTOM, 5)
		hbox1.Add(self.pypilot_mode, 0,  wx.LEFT | wx.EXPAND, 5)

		hbox2 = wx.BoxSizer(wx.HORIZONTAL)
		hbox2.Add(detected_label, 0, wx.ALL | wx.EXPAND, 5)
		hbox2.Add(self.imu_detected, 0, wx.ALL | wx.EXPAND, 5)

		hbox5 = wx.BoxSizer(wx.HORIZONTAL)
		hbox5.Add(self.calibration, 1, wx.ALL | wx.EXPAND, 5)
		hbox5.Add(self.scope, 1, wx.ALL | wx.EXPAND, 5)
		hbox5.Add(self.client, 1, wx.ALL | wx.EXPAND, 5)
		hbox5.Add(self.reset_imu, 1, wx.ALL | wx.EXPAND, 5)

		hbox3 = wx.BoxSizer(wx.HORIZONTAL)
		hbox3.Add(translation_rate_label, 0, wx.TOP | wx.BOTTOM, 5)
		hbox3.Add(self.pypilot_translation_rate, 0,  wx.LEFT, 5)

		vbox1 = wx.StaticBoxSizer(imu_box, wx.VERTICAL)
		vbox1.Add(hbox2, 0, wx.ALL | wx.EXPAND, 5)
		vbox1.Add(hbox5, 0, wx.ALL | wx.EXPAND, 5)
		vbox1.Add(self.pypilot_signalk_translation, 0, wx.ALL | wx.EXPAND, 10)
		vbox1.Add(hbox3, 0, wx.ALL | wx.EXPAND, 5)

		hbox4 = wx.BoxSizer(wx.HORIZONTAL)
		hbox4.Add(pypilot_webapp_port_label, 0, wx.TOP | wx.BOTTOM, 5)
		hbox4.Add(self.pypilot_webapp_port, 0, wx.LEFT, 5)

		vbox2 = wx.StaticBoxSizer(connections_box, wx.VERTICAL)
		vbox2.Add(serial_ports_label, 0, wx.ALL | wx.EXPAND, 5)
		vbox2.Add(self.pypilot_nmea, 1, wx.ALL | wx.EXPAND, 5)
		vbox2.Add(self.pypilot_control, 0, wx.ALL | wx.EXPAND, 5)
		vbox2.Add(self.pypilot_webapp_cb, 0, wx.ALL | wx.EXPAND, 5)
		vbox2.Add(hbox4, 0, wx.ALL | wx.EXPAND, 5)

		hbox8 = wx.BoxSizer(wx.HORIZONTAL)
		hbox8.Add(vbox1, 1, wx.ALL | wx.EXPAND, 5)
		hbox8.Add(vbox2, 0, wx.ALL | wx.EXPAND, 5)

		hbox9 = wx.BoxSizer(wx.HORIZONTAL)
		hbox9.Add(diagnostic, 0, wx.ALL | wx.EXPAND, 5)
		hbox9.Add(restart, 0, wx.ALL | wx.EXPAND, 5)
		hbox9.Add((0, 0), 1, wx.ALL | wx.EXPAND, 5)
		hbox9.Add(apply_changes_pypilot, 0, wx.ALL | wx.EXPAND, 5)
		hbox9.Add(cancel_changes_pypilot, 0, wx.ALL | wx.EXPAND, 5)

		sizer = wx.BoxSizer(wx.VERTICAL)
		sizer.Add(hbox1, 0, wx.ALL | wx.EXPAND, 5)
		sizer.Add(hbox8, 0, wx.ALL | wx.EXPAND, 0)
		sizer.AddStretchSpacer(1)
		sizer.Add(hbox9, 0, wx.EXPAND, 0)

		self.p_pypilot.SetSizer(sizer)

	def disable_autopilot(self):
		self.pypilot_nmea.Disable()
		self.pypilot_control.Disable()
		self.pypilot_webapp_cb.Disable()
		self.pypilot_webapp_port.Disable()

	def enable_autopilot(self):
		self.pypilot_nmea.Enable()
		self.pypilot_control.Enable()
		self.pypilot_webapp_cb.Enable()
		self.pypilot_webapp_port.Enable()
		self.enable_imu()
		i = 0
		for name in self.pypilot_translation_names_list:
			self.pypilot_signalk_translation.Check(i, True)
			i+=1
		self.pypilot_signalk_translation.Disable()
		self.pypilot_translation_rate.Disable()

	def enable_imu(self):
		self.calibration.Enable()
		self.scope.Enable()
		self.client.Enable()
		self.reset_imu.Enable()
		self.pypilot_signalk_translation.Enable()
		self.pypilot_translation_rate.Enable()

	def disable_imu(self):
		self.calibration.Disable()
		self.scope.Disable()
		self.client.Disable()
		self.reset_imu.Disable()
		self.pypilot_signalk_translation.Disable()
		self.pypilot_translation_rate.Disable()

	def select_pypilot(self,e=0):
		mode = self.pypilot_modes[self.pypilot_mode.GetSelection()]

		if mode == 'basic autopilot': 
			self.enable_autopilot()
			if self.SK_settings.pypilot_enabled!=1:
				self.SK_settings.set_pypilot_enable(True)
		else:
			self.disable_autopilot()
			if self.SK_settings.pypilot_enabled==1:
				self.SK_settings.set_pypilot_enable(False)
			if mode == 'imu': 
				self.enable_imu()
			else:
				self.disable_imu()

	def read_pypilot(self, e=0):
		mode = self.conf.get('PYPILOT', 'mode')
		try: i = self.pypilot_modes.index(mode)
		except: i = 0 # disable
		self.pypilot_mode.SetSelection(i)

		try:
			file = open(self.home+'/.pypilot/serial_ports', 'r')
			data = file.read()
			file.close()
			self.pypilot_nmea.SetValue(data)
		except: pass

		self.pypilot_webapp_cb.SetValue(self.conf.get('PYPILOT', 'webapp') == '1')
		try: self.pypilot_webapp_port.SetValue(int(self.conf.get('PYPILOT', 'webapp_port')))
		except: pass

		check_imu = self.check_imu()
		if not check_imu: self.imu_detected.SetLabel(_('Error'))
		else:
			imu_data = eval(check_imu) 
			imu_name = imu_data[0][0]
			self.imu_detected.SetLabel(imu_name)

		self.pypilot_translation_rate.SetStringSelection(self.conf.get('PYPILOT', 'translation_rate'))

		i = 0
		for name in self.pypilot_translation_names_list:
			self.pypilot_signalk_translation.Check(i, self.conf.get('PYPILOT', 'translation_' + name) == '1')
			i+=1
		
		self.select_pypilot()

	def check_imu(self):
		detected_imu = 'Error: ~/.pypilot not found.'
		if  os.path.exists(self.home + '/.pypilot'):
			detected_imu = subprocess.check_output(['python', self.currentpath + '/check_rtimulib.py'], cwd=self.home + '/.pypilot')
		if 'Error:' in detected_imu: 
			print detected_imu
			return
		else:
			l_detected = detected_imu.split('\n')
			for line in l_detected:
				if 'result:' in line: 
					line2 = line.split(':')
					return line2[1]

	def on_pypilot_reset(self, e):
		dlg = wx.MessageDialog(None, _(
			'Compass settings will be deleted.\n\nYou will have to calibrate again.\n\nAre you sure?'),
							   _('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
		if dlg.ShowModal() == wx.ID_YES:
			try:
				os.remove(self.home + '/.pypilot/RTIMULib.ini')
				os.remove(self.home + '/.pypilot/pypilot.conf')
				os.remove(self.home + '/.pypilot/pypilot.conf.bak')
			except: pass
			self.reset_sensors()
		dlg.Destroy()

	def on_pypilot_calibration(self, e):
		subprocess.call(['pkill', '-f', 'pypilot_calibration'])
		subprocess.Popen('pypilot_calibration', cwd=self.home + '/.pypilot')

	def on_pypilot_scope(self, e):
		subprocess.Popen('signalk_scope_wx')

	def on_pypilot_client(self, e):
		subprocess.Popen('signalk_client_wx')

	def on_pypilot_control(self, e):
		subprocess.Popen('pypilot_control', cwd=self.home + '/.pypilot')

	def on_apply_changes_pypilot(self,e=0):
		self.conf.set('PYPILOT', 'mode', self.pypilot_modes[self.pypilot_mode.GetSelection()])

		i = 0
		for name in self.pypilot_translation_names_list:
			self.conf.set('PYPILOT', 'translation_' + name, '1' if self.pypilot_signalk_translation.IsChecked(i) else '0')
			i+=1

		self.conf.set('PYPILOT', 'translation_rate', self.pypilot_translation_rate.GetStringSelection())

		self.conf.set('PYPILOT', 'webapp', '1' if self.pypilot_webapp_cb.GetValue() else '0')
		self.conf.set('PYPILOT', 'webapp_port', str(self.pypilot_webapp_port.GetValue()))

		self.reset_sensors()
		self.restart_SK()

		subprocess.call(['pkill', '-f', 'pypilot_webapp'])
		if self.pypilot_webapp_cb.GetValue() and self.pypilot_mode.GetSelection() == 2:
			subprocess.Popen(['pypilot_webapp', str(self.pypilot_webapp_port.GetValue())])

	def on_cancel_changes_pypilot(self,e):
		self.read_pypilot()

	def start_sensors(self):
		subprocess.Popen(['python', self.currentpath + '/read_sensors_d.py'], cwd=self.home + '/.pypilot')
		self.ShowStatusBarGREEN(_('Sensors restarted'))

	def stop_sensors(self):
		self.ShowStatusBarRED(_('Sensors stopped'))
		subprocess.call(['pkill', '-f', 'pypilot_calibration'])
		subprocess.call(['pkill', '-f', 'signalk_scope_wx'])
		subprocess.call(['pkill', '-f', 'pypilot_control'])
		subprocess.call(['pkill', '-f', 'read_sensors_d.py'])
		
	def reset_sensors(self, e=0):
		self.stop_sensors()
		self.read_i2c()
		self.read_pypilot()
		self.start_sensors()
    
	###########################################kplex

	def page_kplex(self):

		self.list_kplex = CheckListCtrl(self.p_kplex, 650, 152)
		self.list_kplex.InsertColumn(0, _('Name'), width=130)
		self.list_kplex.InsertColumn(1, _('Type'), width=45)
		self.list_kplex.InsertColumn(2, _('io'), width=45)
		self.list_kplex.InsertColumn(3, _('Port/Address'), width=95)
		self.list_kplex.InsertColumn(4, _('Bauds/Port'), width=60)
		self.list_kplex.InsertColumn(5, _('inFilter'), width=55)
		self.list_kplex.InsertColumn(6, _('Filtering'), width=80)
		self.list_kplex.InsertColumn(7, _('outFilter'), width=60)
		self.list_kplex.InsertColumn(8, _('Filtering'), width=80)
		self.list_kplex.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_kplex)

		diagnostic = wx.Button(self.p_kplex, label=_('Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_kplex)

		add = wx.Button(self.p_kplex, label=_('add network'))
		add.Bind(wx.EVT_BUTTON, self.on_add_kplex)
		delete = wx.Button(self.p_kplex, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.on_delete_kplex)

		restart = wx.Button(self.p_kplex, label=_('Restart'))
		restart.Bind(wx.EVT_BUTTON, self.on_restart_kplex)
		advanced = wx.Button(self.p_kplex, label=_('Advanced'))
		advanced.Bind(wx.EVT_BUTTON, self.on_advanced_kplex)
		apply_changes = wx.Button(self.p_kplex, label=_('Apply changes'))
		apply_changes.Bind(wx.EVT_BUTTON, self.on_apply_changes_kplex)
		cancel_changes = wx.Button(self.p_kplex, label=_('Cancel changes'))
		cancel_changes.Bind(wx.EVT_BUTTON, self.on_cancel_changes_kplex)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_kplex, 1, wx.ALL | wx.EXPAND, 5)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add((0, 0), 1, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(add, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(delete, 0, wx.RIGHT | wx.LEFT, 5)

		hboxb = wx.BoxSizer(wx.HORIZONTAL)
		hboxb.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(restart, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(advanced, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add((0, 0), 1, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(apply_changes, 0, wx.RIGHT | wx.LEFT, 5)
		hboxb.Add(cancel_changes, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5)
		vbox.AddSpacer(5)
		vbox.Add(hboxb, 0, wx.ALL | wx.EXPAND, 5)

		self.p_kplex.SetSizer(vbox)

	def on_advanced_kplex(self, event):
		self.ShowMessage(_(
			'OpenPlotter will close. Add manual settings at the end of the configuration file. Open OpenPlotter again and restart multiplexer to apply changes.'))
		subprocess.Popen(['leafpad', self.home + '/.kplex.conf'])
		self.Close()

	def on_restart_kplex(self, event):
		self.ShowStatusBarRED(_('Closing Kplex'))
		subprocess.call(['pkill', '-9', 'kplex'])
		while self.util_process_exist('kplex'):
			time.sleep(0.05)
		time.sleep(0.2)
		subprocess.Popen('kplex')
		try:
			Serialinst = eval(self.conf.get('UDEV', 'serialinst'))
		except:
			Serialinst = {}
		for name in Serialinst:
			if Serialinst[name]['assignment'] == 'NMEA 0183 out':
				subprocess.Popen(['kplex', '-f', self.home+'/.nmea0183out.conf'])
				break
		self.ShowStatusBarGREEN(_('Kplex restarted'))
		self.read_kplex_conf()

	def stop_kplex(self):
		subprocess.call(['pkill', '-9', 'kplex'])
		while self.util_process_exist('kplex'):
			time.sleep(0.05)

	def on_cancel_changes_kplex(self, event):
		self.read_kplex_conf()
		self.ShowStatusBarBLACK('')

	def edit_kplex(self, e):
		idx = e.GetIndex()
		filteronly = 0
		if self.kplex[idx][1] == 'system' or self.kplex[idx][1] == 'signalk' or self.kplex[idx][1] == 'gpsd':
			self.ShowStatusBarBLACK(_('You can only edit filter.'))
			filteronly = 1
		edit = []
		for i in range(9):
			edit.append(self.list_kplex.GetItem(idx, i).GetText())
		edit.append(idx)
		edit.append(filteronly)
		self.edit_add_kplex(edit)

	def on_add_kplex(self, e):
		self.edit_add_kplex(0)

	def edit_add_kplex(self, edit):
		dlg = addkplex(edit, self.kplex, self)
		dlg.ShowModal()
		result = dlg.result
		dlg.Destroy()

		if result != 0:
			k = int(result[11])
			if edit == 0:
				self.kplex.append(result)
				self.set_list_kplex()
			else:
				for i in range(10):
					self.kplex[k][i] = result[i]
				self.set_list_kplex()

	def read_kplex_conf(self):
		self.kplex = []
		try:
			file = open(self.home + '/.kplex.conf', 'r')
			data = file.readlines()
			file.close()

			l_tmp = [None] * 8
			self.manual_settings = ''
			for index, item in enumerate(data):

				if self.manual_settings:
					if item != '\n': self.manual_settings += item
				else:
					if re.search('\[*\]', item):
						if l_tmp[3] == 'in' or l_tmp[3] == 'out' or l_tmp[3] == 'both':
							self.kplex.append(l_tmp)
						l_tmp = [None] * 11
						l_tmp[6] = 'none'
						l_tmp[7] = 'nothing'
						l_tmp[8] = 'none'
						l_tmp[9] = 'nothing'
						if '[serial]' in item: l_tmp[2] = 'Serial'
						if '[tcp]' in item: l_tmp[2] = 'TCP'
						if '[udp]' in item: l_tmp[2] = 'UDP'
						if '#[' in item:
							l_tmp[10] = '0'
						else:
							l_tmp[10] = '1'
					if 'direction=in' in item:
						l_tmp[3] = 'in'
					if 'direction=out' in item:
						l_tmp[3] = 'out'
					if 'direction=both' in item:
						l_tmp[3] = 'both'
					if 'name=' in item and 'filename=' not in item:
						l_tmp[1] = self.extract_value(item)
					if 'address=' in item or 'filename=' in item:
						l_tmp[4] = self.extract_value(item)
						if '/dev' in l_tmp[4]: l_tmp[4] = l_tmp[4][5:]
					if 'port=' in item or 'baud=' in item:
						l_tmp[5] = self.extract_value(item)
					if 'ifilter=' in item and '-all' in item:
						l_tmp[6] = 'accept'
						l_tmp[7] = self.extract_value(item)
					if 'ifilter=' in item and '-all' not in item:
						l_tmp[6] = 'ignore'
						l_tmp[7] = self.extract_value(item)
					if 'ofilter=' in item and '-all' in item:
						l_tmp[8] = 'accept'
						l_tmp[9] = self.extract_value(item)
					if 'ofilter=' in item and '-all' not in item:
						l_tmp[8] = 'ignore'
						l_tmp[9] = self.extract_value(item)
					if '###Manual settings' in item:
						self.manual_settings = '###Manual settings\n\n'

			if l_tmp[3] == 'in' or l_tmp[3] == 'out' or l_tmp[3] == 'both':
				self.kplex.append(l_tmp)

			self.set_list_kplex()

		except IOError:
			self.ShowMessage(_('Multiplexer configuration file does not exist. Add inputs and apply changes.'))

	def extract_value(self, data):
		option, value = data.split('=')
		value = value.strip()
		return value

	def set_list_kplex(self):
		self.list_kplex.DeleteAllItems()
		index = 1
		for i in self.kplex:
			if i[1]:
				index = self.list_kplex.InsertStringItem(sys.maxint, i[1])

			if i[2]: self.list_kplex.SetStringItem(index, 1, i[2])
			if i[3]: self.list_kplex.SetStringItem(index, 2, i[3])
			else:    self.list_kplex.SetStringItem(index, 2, '127.0.0.1')
			if i[4]: self.list_kplex.SetStringItem(index, 3, i[4])
			if i[5]: self.list_kplex.SetStringItem(index, 4, i[5])
			if i[6]:
				if i[6] == 'none': self.list_kplex.SetStringItem(index, 5, _('none'))
				if i[6] == 'accept': self.list_kplex.SetStringItem(index, 5, _('accept'))
				if i[6] == 'ignore': self.list_kplex.SetStringItem(index, 5, _('ignore'))
			if i[7] == 'nothing':
				self.list_kplex.SetStringItem(index, 6, _('nothing'))
			else:
				filters = i[7].replace(':-all', '')
				filters = filters.replace('+', '')
				filters = filters.replace('-', '')
				filters = filters.replace(':', ',')
				self.list_kplex.SetStringItem(index, 6, filters)
			if i[8]:
				if i[8] == 'none': self.list_kplex.SetStringItem(index, 7, _('none'))
				if i[8] == 'accept': self.list_kplex.SetStringItem(index, 7, _('accept'))
				if i[8] == 'ignore': self.list_kplex.SetStringItem(index, 7, _('ignore'))
			if i[9] == 'nothing':
				self.list_kplex.SetStringItem(index, 8, _('nothing'))
			else:
				filters = i[9].replace(':-all', '')
				filters = filters.replace('+', '')
				filters = filters.replace('-', '')
				filters = filters.replace(':', ',')
				self.list_kplex.SetStringItem(index, 8, filters)
			if i[10] == '1': self.list_kplex.CheckItem(index)

	def on_apply_changes_kplex(self, event):
		state = ''
		data = '# For advanced manual configuration, please visit: http://www.stripydog.com/kplex/configuration.html\n# Please do not modify defaults nor OpenPlotter GUI settings.\n# Add manual settings at the end of the document.\n\n'

		data += '###defaults\n\n'
		data += '[udp]\nname=system\ndirection=in\nport=10110\n'
		for index, item in enumerate(self.kplex):
			if 'system' in item[1]:
				if not (item[6] == _('none') or item[6] == 'none') and not (item[7] == _('nothing') or item[7] == 'nothing'): 
					data += state + 'ifilter=' + item[7] + '\n'
				if not (item[8] == _('none') or item[8] == 'none') and not (item[9] == _('nothing') or item[9] == 'nothing'): 
					data += state + 'ofilter=' + item[9] + '\n'
				data += '\n'
		data += '[tcp]\nname=signalk\ndirection=out\nmode=server\nport=30330\n\n'
		for index, item in enumerate(self.kplex):
			if 'signalk' in item[1]:
				if not (item[6] == _('none') or item[6] == 'none') and not (item[7] == _('nothing') or item[7] == 'nothing'): 
					data += state + 'ifilter=' + item[7] + '\n'
				if not (item[8] == _('none') or item[8] == 'none') and not (item[9] == _('nothing') or item[9] == 'nothing'): 
					data += state + 'ofilter=' + item[9] + '\n'
				data += '\n'

		data += '###end of defaults\n\n###OpenPlotter GUI settings\n\n'

		for index, item in enumerate(self.kplex):
			if not ('system' in item[1] or 'signalk' in item[1]):
				if self.list_kplex.IsChecked(index):
					state = ''
				else:
					state = '#'

				if 'Serial' in item[2]:
					data += state + '[serial]\n' + state + 'name=' + item[1] + '\n' + state + 'direction=' + item[
						3] + '\n' + state + 'optional=yes\n'
					data += state + 'filename=/dev/' + item[4] + '\n' + state + 'baud=' + item[5] + '\n'
				if 'TCP' in item[2]:
					data += state + '[tcp]\n' + state + 'name=' + item[1] + '\n' + state + 'direction=' + item[
						3] + '\n' + state + 'optional=yes\n'
					if item[1] == 'gpsd': data += state + 'gpsd=yes\n'
					if item[3] <> 'out':
						data += state + 'mode=client\n'
						data += state + 'persist=yes\n' + state + 'retry=10\n'
					else:
						data += state + 'mode=server\n'
					if item[4]: data += state + 'address=' + str(item[4]) + '\n' 
					data += state + 'port=' + str(item[5]) + '\n'
				if 'UDP' in item[2]:
					data += state + '[udp]\n' + state + 'name=' + item[1] + '\n' + state + 'direction=' + item[
						3] + '\n' + state + 'optional=yes\n'
					data += state + 'address=' + item[4] + '\n' + state + 'port=' + item[5] + '\n'

				if not (item[6] == _('none') or item[6] == 'none') and not (item[7] == _('nothing') or item[7] == 'nothing'): 
					data += state + 'ifilter=' + item[7] + '\n'
				if not (item[8] == _('none') or item[8] == 'none') and not (item[9] == _('nothing') or item[9] == 'nothing'): 
					data += state + 'ofilter=' + item[9] + '\n'
				data += '\n'

		data += '###end of OpenPlotter GUI settings\n\n'
		if self.manual_settings:
			data += self.manual_settings
		else:
			data += '###Manual settings\n\n'

		file = open(self.home + '/.kplex.conf', 'w')
		file.write(data)
		file.close()
		self.on_restart_kplex(0)
		self.read_kplex_conf()

	def on_delete_kplex(self, event):
		selected = self.list_kplex.GetFirstSelected()
		if selected == -1:
			self.ShowStatusBarRED(_('Select an item.'))
			return
		num = len(self.kplex)
		for i in range(num):
			if self.list_kplex.IsSelected(i):
				if self.kplex[i][1] == 'system' or self.kplex[i][1] == 'signalk':
					self.ShowStatusBarRED(_('You can not delete this'))
					return
				if self.kplex[i][2] == 'Serial' or self.kplex[i][1] == 'gpsd':
					self.ShowStatusBarRED(_('Unassign this device on "Serial ports" tab'))
					return	
				del self.kplex[i]
		self.set_list_kplex()

	def on_diagnostic_kplex(self, event):
		selected = self.list_kplex.GetFirstSelected()
		if selected == -1:
			self.ShowStatusBarRED(_('Select an item.'))
			return
		num = len(self.kplex)
		for i in range(num):
			if self.list_kplex.IsSelected(i):
				if self.list_kplex.IsChecked(i):
					file = open(self.home + '/.kplex.conf', 'r')
					data = file.read()
					file.close()

					if self.kplex[i][3] == 'in' or self.kplex[i][3] == 'both':
						data = data + '\n\n[tcp]\nname=system_debugi\ndirection=out\nofilter=+*****%' + self.kplex[i][
							1] + ':-all\nmode=server\nport=10112\n\n'
					if self.kplex[i][3] == 'out' or self.kplex[i][3] == 'both':
						data += '\n\n[tcp]\nname=system_debugo\ndirection=out\n'
						if self.kplex[i][8] != 'none' and self.kplex[i] != 'nothing': data += 'ofilter=' + \
																							  self.kplex[i][9] + '\n'
						data += 'mode=server\nport=10113\n\n'

					file = open(self.home + '/.debugkplex.conf', 'w')
					file.write(data)
					file.close()

					self.stop_kplex()
					time.sleep(0.2)
					subprocess.Popen(['kplex', '-f', self.home + '/.debugkplex.conf'])
					time.sleep(0.5)
					subprocess.call(['pkill', '-f', 'diagnostic-NMEA.py'])
					if self.kplex[i][3] == 'in' or self.kplex[i][3] == 'both':
						subprocess.Popen(['python', self.currentpath + '/diagnostic-NMEA.py', '10112', 'diagnostic_input'])
					if self.kplex[i][3] == 'out' or self.kplex[i][3] == 'both':
						subprocess.Popen(['python', self.currentpath + '/diagnostic-NMEA.py', '10113', 'diagnostic_output'])
					
					try:
						Serialinst = eval(self.conf.get('UDEV', 'serialinst'))
					except:
						Serialinst = {}
					for name in Serialinst:
						if Serialinst[name]['assignment'] == 'NMEA 0183 out':
							subprocess.Popen(['kplex', '-f', self.home+'/.nmea0183out.conf'])
							break

	###########################################I2C

	def page_i2c(self):
		self.i2c_sensors_def = []
		self.i2c_sensors_def.append(['BMP180','rtimulib.press.2.',['pressure','temperature'],['environment.outside.pressure','']])
		self.i2c_sensors_def.append(['LPS25H','rtimulib.press.3.',['pressure','temperature'],['environment.outside.pressure','']])
		self.i2c_sensors_def.append(['MS5611','rtimulib.press.4.',['pressure','temperature'],['environment.outside.pressure','']])
		self.i2c_sensors_def.append(['MS5637','rtimulib.press.5.',['pressure','temperature'],['environment.outside.pressure','']])
		self.i2c_sensors_def.append(['HTS221','rtimulib.hum.2.',['humidity','temperature'],['environment.inside.humidity','']])
		self.i2c_sensors_def.append(['HTU21D','rtimulib.hum.3.',['humidity','temperature'],['environment.inside.humidity','']])
		self.i2c_sensors_def.append(['BME280','0x76',['pressure','temperature','humidity'],['environment.outside.pressure','','environment.inside.humidity']])
		self.i2c_sensors_def.append(['MS5607-02BA03','0x77',['pressure','temperature'],['environment.outside.pressure','']])
		#self.i2c_sensors_def.append(['Si7020-A20','0x40',['humidity','temperature'],['environment.inside.humidity','']])
		title = wx.StaticText(self.p_i2c, label=_(' Sensors '))

		self.list_i2c = wx.ListCtrl(self.p_i2c, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
		self.list_i2c.InsertColumn(0, ' ', width=15)
		self.list_i2c.InsertColumn(1, _('Name'), width=150)
		self.list_i2c.InsertColumn(2, _('Address'), width=45)
		self.list_i2c.InsertColumn(3, _('Magnitude'), width=90)
		self.list_i2c.InsertColumn(4, _('Signal K key'), width=200)
		self.list_i2c.InsertColumn(5, _('Rate'), width=40)
		self.list_i2c.InsertColumn(6, _('Offset'), width=50)
		self.list_i2c.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_i2c)
		self.list_i2c.Bind(wx.EVT_LIST_ITEM_SELECTED, self.edit_i2c)

		add = wx.Button(self.p_i2c, label=_('add'))
		add.Bind(wx.EVT_BUTTON, self.on_add_i2c)

		delete = wx.Button(self.p_i2c, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.on_delete_i2c)

		diagnostic = wx.Button(self.p_i2c, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		reset_i2c = wx.Button(self.p_i2c, label=_('Restart'))
		reset_i2c.Bind(wx.EVT_BUTTON, self.reset_sensors)

		hlistbox_but = wx.BoxSizer(wx.VERTICAL)
		hlistbox_but.Add(add, 0, wx.ALL, 5)
		hlistbox_but.Add(delete, 0, wx.ALL, 5)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_i2c, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox.Add(hlistbox_but, 0, wx.RIGHT | wx.LEFT, 0)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(reset_i2c, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5)

		self.p_i2c.SetSizer(vbox)

	def edit_i2c(self, e):
		selected = self.list_i2c.GetFirstSelected()
		name = self.list_i2c.GetItem(selected, 1)
		name = name.GetText()
		index = self.list_i2c.GetItem(selected, 0)
		index = index.GetText()
		magn = self.list_i2c.GetItem(selected, 3)
		magn = magn.GetText()
		sk = self.list_i2c.GetItem(selected, 4)
		sk = sk.GetText()
		rate = self.list_i2c.GetItem(selected, 5)
		rate = rate.GetText()
		offset = self.list_i2c.GetItem(selected, 6)
		offset = offset.GetText()

		dlg = editI2c(name,magn,sk,rate,offset)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			sk = dlg.SKkey.GetValue()
			rate = dlg.rate.GetValue()
			offset = dlg.offset.GetValue()
			if not offset: offset = 0.0
			c = 0
			for i in self.i2c_sensors:
				if i[0] == name:
					self.i2c_sensors[c][2][int(index)][0] = sk.encode('utf8')
					self.i2c_sensors[c][2][int(index)][1] = float(rate)
					self.i2c_sensors[c][2][int(index)][2] = float(offset)
				c = c + 1
			self.apply_changes_i2c()
		dlg.Destroy()

	def on_add_i2c(self, e):
		dlg = addI2c(self)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			name = dlg.sensor_select.GetValue()
			if not name:
				self.ShowMessage(_('Failed. You must select a sensor.'))
				dlg.Destroy()
				return
			address = dlg.address.GetValue()
			if not address:
				self.ShowMessage(_('Failed. You must provide an address.'))
				dlg.Destroy()
				return
			new_sensor = []
			for item in self.i2c_sensors_def:
				if name == item[0]:
					new_sensor.append(name.encode('utf8'))
					if 'rtimulib' in item[1]:
						new_sensor.append((item[1]+address).encode('utf8'))
					else:
						new_sensor.append(address.encode('utf8'))
					new_sensor.append([])	
					for ii in item[3]:
						new_sensor[2].append([ii, 1.0, 0.0])
			if new_sensor:
				if 'rtimulib' in new_sensor[1]:
					temp_list = new_sensor[1].split('.')
					try:
						with open(self.home + '/.pypilot/RTIMULib2.ini', "r") as infile:
							data = ''
							if temp_list[1] == 'press':
								for line in infile:
									if 'PressureType=' in line:
										data += 'PressureType='+temp_list[2]+'\n'
									elif 'I2CPressureAddress=' in line:
										data += 'I2CPressureAddress='+str(int(temp_list[3], 0))+'\n'
									elif 'BusIsI2C=' in line:
										data += 'BusIsI2C=true'+'\n'
									else:
										data += line
							if temp_list[1] == 'hum':
								for line in infile:
									if 'HumidityType=' in line:
										data += 'HumidityType='+temp_list[2]+'\n'
									elif 'I2CHumidityAddress=' in line:
										data += 'I2CHumidityAddress='+str(int(temp_list[3], 0))+'\n'
									elif 'BusIsI2C=' in line:
										data += 'BusIsI2C=true'+'\n'
									else:
										data += line
						with open(self.home + '/.pypilot/RTIMULib2.ini', "w") as outfile:
							outfile.write(data) 
					except Exception, e: 
						print "RTIMU setting failed: "+str(e)
						dlg.Destroy()
						return
				exist = False
				c = 0
				for i in self.i2c_sensors:
					if i[0] == new_sensor[0]: 
						self.i2c_sensors[c] = new_sensor
						exist = True
						break
					c = c + 1
				if exist == False and 'rtimulib' in new_sensor[1]:
					tmp = new_sensor[1].split('.')
					c = 0
					for iii in self.i2c_sensors:
						if 'rtimulib' in iii[1]:
							tmp2 = iii[1].split('.')
							if tmp[1] == tmp2[1]:
								self.i2c_sensors[c] = new_sensor
								exist = True
								break
						c = c + 1
				if exist == False: self.i2c_sensors.append(new_sensor)
				self.apply_changes_i2c()
		dlg.Destroy()

	def apply_changes_i2c(self):
		self.conf.set('I2C', 'sensors', str(self.i2c_sensors))
		self.stop_sensors()
		self.read_i2c()
		self.start_sensors()

	def on_delete_i2c(self, e):
		selected = self.list_i2c.GetFirstSelected()
		if selected == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
			return
		name = self.list_i2c.GetItem(selected, 1)
		name = name.GetText()
		c = 0
		for i in self.i2c_sensors:
			if i[0] == name: 
				del self.i2c_sensors[c]
				break
			c = c + 1
		self.apply_changes_i2c()

	def read_i2c(self):
		self.i2c_sensors = []
		self.list_i2c.DeleteAllItems()
		data = self.conf.get('I2C', 'sensors')
		try:
			self.i2c_sensors = eval(data)
		except:
			self.i2c_sensors = []
		for i in self.i2c_sensors:
			name = i[0]
			for ii in self.i2c_sensors_def:
				if name == ii[0]: 
					magn_list = ii[2]
					break
			address = i[1]
			if 'rtimulib' in address:
				tmp = address.split('.')
				address = tmp[3]
			c = 0
			for iii in i[2]:
				self.list_i2c.Append([str(c), name, address, magn_list[c], iii[0], str(iii[1]), str(iii[2])])
				c = c + 1

	###########################################SPI

	def page_spi(self):
		title = wx.StaticText(self.p_spi, label=_(' SPI MCP3008 '))

		self.list_MCP = CheckListCtrl(self.p_spi, 565, 100)
		#self.list_MCP = wx.ListCtrl(self.p_spi, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER)
		self.list_MCP.InsertColumn(0, _('aktiv'), width=45)
		self.list_MCP.InsertColumn(1, _('channel'), width=65)
		self.list_MCP.InsertColumn(2, _('Signal K key'), width=380)
		self.list_MCP.InsertColumn(3, _('convert'), width=55)
		self.list_MCP.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_edit_MCP)
		self.list_MCP.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_edit_MCP)
		self.list_MCP.Bind(wx.EVT_LEFT_DOWN, self.on_checkbox_MCP)
		diagnostic = wx.Button(self.p_spi, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		restart = wx.Button(self.p_spi, label=_('Restart'))
		restart.Bind(wx.EVT_BUTTON, self.on_restart_MCP)

		value_setting = wx.Button(self.p_spi, label=_('value setting'))
		value_setting.Bind(wx.EVT_BUTTON, self.on_value_setting)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_MCP, 1, wx.ALL | wx.EXPAND, 5)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(restart, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add((0, 0), 1, wx.RIGHT | wx.EXPAND, 5)
		hbox.Add(value_setting, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5)

		self.p_spi.SetSizer(vbox)

	def read_MCP(self):
		self.MCP = []
		self.list_MCP.DeleteAllItems()
		data = self.conf.get('SPI', 'mcp')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.MCP.append(ii)
			self.list_MCP.Append(['', ii[1], ii[2], ii[4]])
			if ii[0] == 1:
				last = self.list_MCP.GetItemCount() - 1
				self.list_MCP.CheckItem(last)
				
	def on_checkbox_MCP(self, e):
		pass

	def on_restart_MCP(self, e):
		self.stop_sensors()
		self.start_sensors()

	def on_value_setting(self, e):
		edit = self.list_MCP.GetFirstSelected()
		if edit == -1:
			return
		dlg = addvaluesetting(edit, self)
		dlg.ShowModal()

		if self.MCP[edit][4] == 1:
			convert = 1
			self.conf.read()
			data = self.conf.get('SPI', 'value_' + str(edit))
			try:
				temp_list = eval(data)
			except:
				temp_list = []
			min = 1023
			max = 0
			for ii in temp_list:
				if ii[0] > max: max = ii[0]
				if ii[0] < min: min = ii[0]
			if min > 0:
				wx.MessageBox(_('minimum raw value in setting table > 0'), 'info', wx.OK | wx.ICON_INFORMATION)
				convert = 0
			if max < 1023:
				wx.MessageBox(_('maximum raw value in setting table < 1023'), 'info', wx.OK | wx.ICON_INFORMATION)
				convert = 0
			if convert == 0:
				self.MCP[edit][4] = convert
				self.conf.set('SPI', 'mcp', str(self.MCP))
				self.read_MCP()
				wx.MessageBox(_('convert disabled'), 'info', wx.OK | wx.ICON_INFORMATION)

	def on_edit_MCP(self, e):
		t = e.GetIndex()
			
		aktiv = self.MCP[t][0]
		channel = self.MCP[t][1]
		SKkey = self.MCP[t][2]
		convert = self.MCP[t][4]
		dlg = editMCP(aktiv, channel, SKkey, convert,self)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			SKkey = dlg.SKkey.GetValue().encode('utf8')
			aktiv = dlg.aktiv.GetValue()
			if aktiv:
				aktiv = 1
			else:
				aktiv = 0
			convert = dlg.convert.GetValue()
			if convert:
				convert = 1
			else:
				convert = 0
				
			self.MCP[t][0] = aktiv
			self.MCP[t][1] = channel
			self.MCP[t][2] = SKkey
			self.MCP[t][3] = ""
			self.MCP[t][4] = convert
			self.conf.set('SPI', 'mcp', str(self.MCP))
		dlg.Destroy()
		self.conf.read()
		self.read_MCP()

	###########################################Credentials
	
	def page_credentials(self):

		self.localbrokerid = 'openplot.lmqtt'
		self.remotebrokerid = 'openplot.rmqtt'
		self.twitterid = 'openplot.twitt'
		self.telegramid = 'openplot.teleg'
		
		self.localmqtt = wx.CheckBox(self.p_credentials, label=_('Enable local MQTT broker'))
		self.localmqtt.Bind(wx.EVT_CHECKBOX, self.on_localmqtt)
		userlocalmqttlabel = wx.StaticText(self.p_credentials, label=_('Username'))
		self.userlocalmqtt = wx.TextCtrl(self.p_credentials)
		passlocalmqttlabel = wx.StaticText(self.p_credentials, label=_('Password'))
		self.passlocalmqtt = wx.TextCtrl(self.p_credentials, style=wx.TE_PASSWORD)

		self.remotemqtt = wx.CheckBox(self.p_credentials, label=_('Enable remote MQTT broker'))
		self.remotemqtt.Bind(wx.EVT_CHECKBOX, self.on_remotemqtt)
		serverremotemqttlabel = wx.StaticText(self.p_credentials, label=_('Server'))
		self.serverremotemqtt = wx.TextCtrl(self.p_credentials)
		portremotemqttlabel = wx.StaticText(self.p_credentials, label=_('Port'))
		self.portremotemqtt = wx.SpinCtrl(self.p_credentials, min=1, max=65000, initial=1883)
		userremotemqttlabel = wx.StaticText(self.p_credentials, label=_('Username'))
		self.userremotemqtt = wx.TextCtrl(self.p_credentials)
		passremotemqttlabel = wx.StaticText(self.p_credentials, label=_('Password'))
		self.passremotemqtt = wx.TextCtrl(self.p_credentials, style=wx.TE_PASSWORD)

		self.twitter = wx.CheckBox(self.p_credentials, label=_('Enable Twitter account'))
		self.twitter.Bind(wx.EVT_CHECKBOX, self.on_twitter)
		twitteraccountlabel = wx.StaticText(self.p_credentials, label=_('Twitter ID'))
		self.twitteraccount = wx.TextCtrl(self.p_credentials)
		apikeylabel = wx.StaticText(self.p_credentials, label=_('API key'))
		self.apikey = wx.TextCtrl(self.p_credentials, style=wx.TE_PASSWORD)
		apisecretkeylabel = wx.StaticText(self.p_credentials, label=_('API secret key'))
		self.apisecretkey = wx.TextCtrl(self.p_credentials, style=wx.TE_PASSWORD)
		accesstokenlabel = wx.StaticText(self.p_credentials, label=_('Access token'))
		self.accesstoken = wx.TextCtrl(self.p_credentials, style=wx.TE_PASSWORD)
		accesstokensecretlabel = wx.StaticText(self.p_credentials, label=_('Access token secret'))
		self.accesstokensecret = wx.TextCtrl(self.p_credentials, style=wx.TE_PASSWORD)

		self.telegram = wx.CheckBox(self.p_credentials, label=_('Enable Telegram bot'))
		self.telegram.Bind(wx.EVT_CHECKBOX, self.on_telegram)
		tokenlabel = wx.StaticText(self.p_credentials, label=_('Token'))
		self.token = wx.TextCtrl(self.p_credentials, style=wx.TE_PASSWORD)
		userslabel = wx.StaticText(self.p_credentials, label=_('Users'))
		self.users = wx.TextCtrl(self.p_credentials)

		help_button = wx.BitmapButton(self.p_credentials, bitmap=self.help_bmp, size=(self.help_bmp.GetWidth()+40, self.help_bmp.GetHeight()+10))
		help_button.Bind(wx.EVT_BUTTON, self.on_help_credentials)
		self.encrypt = wx.Button(self.p_credentials, label=_('Encrypt'))
		self.encrypt.Bind(wx.EVT_BUTTON, self.on_encrypt)
		self.decrypt = wx.Button(self.p_credentials, label=_('Decrypt'))
		self.decrypt.Bind(wx.EVT_BUTTON, self.on_decrypt)

		self.apply_changes_cre = wx.Button(self.p_credentials, label=_('Apply changes'))
		self.apply_changes_cre.Bind(wx.EVT_BUTTON, self.on_apply_changes_credentials)
		self.cancel_changes_cre = wx.Button(self.p_credentials, label=_('Cancel changes'))
		self.cancel_changes_cre.Bind(wx.EVT_BUTTON, self.on_cancel_changes_credentials)

		localmqtt = wx.BoxSizer(wx.HORIZONTAL)
		localmqtt.AddSpacer(25)
		localmqtt.Add(userlocalmqttlabel, 0, wx.TOP | wx.BOTTOM, 6)
		localmqtt.Add(self.userlocalmqtt, 1, wx.LEFT, 5)
		localmqtt.AddSpacer(10)
		localmqtt.Add(passlocalmqttlabel, 0, wx.TOP | wx.BOTTOM, 6)
		localmqtt.Add(self.passlocalmqtt, 1, wx.LEFT, 5)

		remotemqtt0 = wx.BoxSizer(wx.HORIZONTAL)
		remotemqtt0.Add(self.remotemqtt, 0, wx.TOP | wx.BOTTOM, 2)
		remotemqtt0.AddSpacer(10)		
		remotemqtt0.Add(serverremotemqttlabel, 0, wx.TOP | wx.BOTTOM, 6)
		remotemqtt0.Add(self.serverremotemqtt, 1, wx.LEFT, 5)
		remotemqtt0.AddSpacer(10)		
		remotemqtt0.Add(portremotemqttlabel, 0, wx.TOP | wx.BOTTOM, 6)
		remotemqtt0.Add(self.portremotemqtt, 0, wx.LEFT, 5)

		remotemqtt = wx.BoxSizer(wx.HORIZONTAL)
		remotemqtt.AddSpacer(25)
		remotemqtt.Add(userremotemqttlabel, 0, wx.TOP | wx.BOTTOM, 6)
		remotemqtt.Add(self.userremotemqtt, 1, wx.LEFT, 5)
		remotemqtt.AddSpacer(10)
		remotemqtt.Add(passremotemqttlabel, 0, wx.TOP | wx.BOTTOM, 6)
		remotemqtt.Add(self.passremotemqtt, 1, wx.LEFT, 5)

		twitter0 = wx.BoxSizer(wx.HORIZONTAL)
		twitter0.Add(self.twitter, 0, wx.TOP | wx.BOTTOM, 2)
		twitter0.AddSpacer(10)
		twitter0.Add(twitteraccountlabel, 0, wx.TOP | wx.BOTTOM, 6)
		twitter0.Add(self.twitteraccount, 1, wx.LEFT, 5)

		twitter1 = wx.BoxSizer(wx.HORIZONTAL)
		twitter1.AddSpacer(25)
		twitter1.Add(apikeylabel, 0, wx.TOP | wx.BOTTOM, 6)
		twitter1.Add(self.apikey, 1, wx.LEFT, 5)
		twitter1.AddSpacer(10)
		twitter1.Add(apisecretkeylabel, 0, wx.TOP | wx.BOTTOM, 6)
		twitter1.Add(self.apisecretkey, 1, wx.LEFT, 5)

		twitter2 = wx.BoxSizer(wx.HORIZONTAL)
		twitter2.AddSpacer(25)
		twitter2.Add(accesstokenlabel, 0, wx.TOP | wx.BOTTOM, 6)
		twitter2.Add(self.accesstoken, 1, wx.LEFT, 5)
		twitter2.AddSpacer(10)
		twitter2.Add(accesstokensecretlabel, 0, wx.TOP | wx.BOTTOM, 6)
		twitter2.Add(self.accesstokensecret, 1, wx.LEFT, 5)

		telegram0 = wx.BoxSizer(wx.HORIZONTAL)
		telegram0.Add(self.telegram, 0, wx.TOP | wx.BOTTOM, 2)
		telegram0.AddSpacer(10)
		telegram0.Add(tokenlabel, 0, wx.TOP | wx.BOTTOM, 6)
		telegram0.Add(self.token, 1, wx.LEFT, 5)

		telegram1 = wx.BoxSizer(wx.HORIZONTAL)
		telegram1.AddSpacer(25)
		telegram1.Add(userslabel, 0, wx.TOP | wx.BOTTOM, 6)
		telegram1.Add(self.users, 1, wx.LEFT, 5)

		buttons = wx.BoxSizer(wx.HORIZONTAL)
		buttons.Add(help_button, 0, wx.RIGHT, 5)
		buttons.Add(self.encrypt, 0, wx.RIGHT | wx.LEFT, 5)
		buttons.Add(self.decrypt, 0, wx.RIGHT | wx.LEFT, 5)
		buttons.Add((0, 0), 1, wx.RIGHT | wx.LEFT, 5)
		buttons.Add(self.apply_changes_cre, 0, wx.RIGHT | wx.LEFT, 5)
		buttons.Add(self.cancel_changes_cre, 0, wx.RIGHT | wx.LEFT, 5)

		main = wx.BoxSizer(wx.VERTICAL)
		main.Add(self.localmqtt, 0, wx.TOP | wx.BOTTOM, 2)
		main.Add(localmqtt, 0, wx.ALL | wx.EXPAND, 0)
		main.AddSpacer(10)		
		main.Add(remotemqtt0, 0, wx.EXPAND, 0)
		main.AddSpacer(3)		
		main.Add(remotemqtt, 0, wx.ALL | wx.EXPAND, 0)
		main.AddSpacer(10)		
		main.Add(twitter0, 0, wx.ALL | wx.EXPAND, 0)
		main.AddSpacer(3)		
		main.Add(twitter1, 0, wx.ALL | wx.EXPAND, 0)
		main.AddSpacer(3)		
		main.Add(twitter2, 0, wx.ALL | wx.EXPAND, 0)
		main.AddSpacer(10)		
		main.Add(telegram0, 0, wx.ALL | wx.EXPAND, 0)
		main.AddSpacer(3)		
		main.Add(telegram1, 0, wx.ALL | wx.EXPAND, 0)
		main.AddStretchSpacer(1)		
		main.Add(buttons, 0, wx.ALL | wx.EXPAND, 5)

		self.p_credentials.SetSizer(main)

	def on_encrypt(self, e):
		add_nodes = []
		remove_ids = []			
		dlg = wx.MessageDialog(None, _(
			'All current credentials will be deleted and actions that use them will stop working. Actions that need credentials should be defined in the Node-RED admin interface.\n\nAre you sure?'),
							   _('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
		if dlg.ShowModal() != wx.ID_YES:	
			dlg.Destroy()
			return

		os.remove(self.cred_file)

		self.conf.set('CREDENTIALS', 'encrypted', '1')
		self.conf.set('CREDENTIALS', 'local_mqtt', '0')
		self.conf.set('CREDENTIALS', 'remote_mqtt', '0')
		self.conf.set('CREDENTIALS', 'twitter', '0')
		self.conf.set('CREDENTIALS', 'telegram', '0')

		remove_ids.append(self.localbrokerid)
		remove_ids.append(self.remotebrokerid)
		remove_ids.append(self.twitterid)
		remove_ids.append(self.telegramid)
		remove_ids.append(self.telegramid+'1')
		remove_ids.append(self.telegramid+'2')
		remove_ids.append(self.telegramid+'3')
		remove_ids.append(self.telegramid+'4')
		remove_ids.append(self.telegramid+'5')
		self.nodes.edit_flow(add_nodes, remove_ids)

		ndsettings = self.home+'/.signalk/node_modules/@signalk/signalk-node-red/index.js'
		tmpndsettings = self.home+'/.cre'
		file = open(ndsettings, 'r')
		file1 = open(tmpndsettings, 'w')
		while True:
			line = file.readline()
			if not line: break
			if 'credentialSecret:' in line:
				line2 = '      credentialSecret: "'+self.nodes.get_node_id()+'",\n'
				file1.write(line2)
			else: file1.write(line)
		file.close()
		file1.close()
		os.system('mv '+tmpndsettings+' '+ndsettings)

		self.print_credentials()
		self.restart_SK()
		seconds = 15
		for i in range(seconds, 0, -1):
			self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Starting Node-Red... ')+str(i))
			time.sleep(1)
		self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Node-Red restarted'))

	def on_decrypt(self, e):	
		dlg = wx.MessageDialog(None, _(
			'Credentials created outside of OpenPlotter interface will be deleted and its nodes will stop working. Your new credentials will be stored without encryption, do not use your usual passwords.\n\nAre you sure?'),
							   _('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
		if dlg.ShowModal() != wx.ID_YES:	
			dlg.Destroy()
			return

		os.remove(self.cred_file)

		self.conf.set('CREDENTIALS', 'encrypted', '0')

		ndsettings = self.home+'/.signalk/node_modules/@signalk/signalk-node-red/index.js'
		tmpndsettings = self.home+'/.cre'
		file = open(ndsettings, 'r')
		file1 = open(tmpndsettings, 'w')
		while True:
			line = file.readline()
			if not line: break
			if 'credentialSecret:' in line:
				line2 = '      credentialSecret: false,\n'
				file1.write(line2)
			else: file1.write(line)
		file.close()
		file1.close()
		os.system('mv '+tmpndsettings+' '+ndsettings)

		self.print_credentials()
		self.restart_SK()
		seconds = 15
		for i in range(seconds, 0, -1):
			self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Starting Node-Red... ')+str(i))
			time.sleep(1)
		self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Node-Red restarted'))

	def read_credentials(self):
		self.cred_file = self.home+'/.signalk/red/flows_openplotter_cred.json'
		try:
			with open(self.cred_file) as data_file:
				credentials = ujson.load(data_file)
			return credentials
		except:
			return {}
			print "ERROR reading credentials file"

	def print_credentials(self):
		if self.conf.get('CREDENTIALS', 'encrypted') == '1':
			self.localmqtt.Disable()
			self.localmqtt.SetValue(False)
			self.userlocalmqtt.Disable()
			self.passlocalmqtt.Disable()
			self.userlocalmqtt.SetValue('')
			self.passlocalmqtt.SetValue('')
			self.remotemqtt.Disable()
			self.remotemqtt.SetValue(False)
			self.serverremotemqtt.Disable()
			self.portremotemqtt.Disable()
			self.userremotemqtt.Disable()
			self.passremotemqtt.Disable()
			self.userremotemqtt.SetValue('')
			self.passremotemqtt.SetValue('')
			self.serverremotemqtt.SetValue('')
			self.portremotemqtt.SetValue(1883)
			self.twitter.Disable()
			self.twitter.SetValue(False)
			self.twitteraccount.Disable()
			self.apikey.Disable()
			self.apisecretkey.Disable()
			self.accesstoken.Disable()
			self.accesstokensecret.Disable()
			self.twitteraccount.SetValue('')
			self.apikey.SetValue('')
			self.apisecretkey.SetValue('')
			self.accesstoken.SetValue('')
			self.accesstokensecret.SetValue('')
			self.telegram.Disable()
			self.telegram.SetValue(False)
			self.token.Disable()
			self.users.Disable()
			self.token.SetValue('')
			self.users.SetValue('')
			self.encrypt.Disable()
			self.decrypt.Enable()
			self.apply_changes_cre.Disable()
			self.cancel_changes_cre.Disable()
		else:
			self.localmqtt.Enable()
			self.remotemqtt.Enable()
			self.twitter.Enable()
			self.telegram.Enable()
			self.encrypt.Enable()
			self.decrypt.Disable()
			self.apply_changes_cre.Enable()
			self.cancel_changes_cre.Enable()
			credentials = self.read_credentials()
			if self.conf.get('CREDENTIALS', 'local_mqtt') == '1':
				self.localmqtt.SetValue(True)
				try:
					self.userlocalmqtt.SetValue(credentials[self.localbrokerid]['user'])
					self.passlocalmqtt.SetValue(credentials[self.localbrokerid]['password'])
				except: pass
				self.userlocalmqtt.Disable()
				self.passlocalmqtt.Disable()
			else:
				self.localmqtt.SetValue(False)
				self.userlocalmqtt.SetValue('')
				self.passlocalmqtt.SetValue('')
				self.userlocalmqtt.Enable()
				self.passlocalmqtt.Enable()
			if self.conf.get('CREDENTIALS', 'remote_mqtt') == '1':
				self.remotemqtt.SetValue(True)
				try:
					self.userremotemqtt.SetValue(credentials[self.remotebrokerid]['user'])
					self.passremotemqtt.SetValue(credentials[self.remotebrokerid]['password'])
				except: pass
				for i in self.no_actions_nodes:
					if i['id'] == self.remotebrokerid: 
						self.serverremotemqtt.SetValue(i['broker'])
						self.portremotemqtt.SetValue(int(i['port']))
				self.serverremotemqtt.Disable()
				self.portremotemqtt.Disable()
				self.userremotemqtt.Disable()
				self.passremotemqtt.Disable()
			else:
				self.remotemqtt.SetValue(False)
				self.userremotemqtt.SetValue('')
				self.passremotemqtt.SetValue('')
				self.serverremotemqtt.SetValue('')
				self.portremotemqtt.SetValue(1883)
				self.serverremotemqtt.Enable()
				self.portremotemqtt.Enable()
				self.userremotemqtt.Enable()
				self.passremotemqtt.Enable()

			if self.conf.get('CREDENTIALS', 'twitter') == '1':
				self.twitter.SetValue(True)
				try:
					self.apikey.SetValue(credentials[self.twitterid]['consumer_key'])
					self.apisecretkey.SetValue(credentials[self.twitterid]['consumer_secret'])
					self.accesstoken.SetValue(credentials[self.twitterid]['access_token'])
					self.accesstokensecret.SetValue(credentials[self.twitterid]['access_token_secret'])
				except: pass
				for i in self.no_actions_nodes:
					if i['id'] == self.twitterid: 
						self.twitteraccount.SetValue(i['screen_name'])
				self.twitteraccount.Disable()
				self.apikey.Disable()
				self.apisecretkey.Disable()
				self.accesstoken.Disable()
				self.accesstokensecret.Disable()
			else:
				self.twitter.SetValue(False)
				self.twitteraccount.SetValue('')
				self.apikey.SetValue('')
				self.apisecretkey.SetValue('')
				self.accesstoken.SetValue('')
				self.accesstokensecret.SetValue('')
				self.twitteraccount.Enable()
				self.apikey.Enable()
				self.apisecretkey.Enable()
				self.accesstoken.Enable()
				self.accesstokensecret.Enable()

			if self.conf.get('CREDENTIALS', 'telegram') == '1':
				self.telegram.SetValue(True)
				try:
					self.token.SetValue(credentials[self.telegramid]['token'])
				except: pass
				for i in self.no_actions_nodes:
					if i['id'] == self.telegramid: 
						self.users.SetValue(i['usernames'])
				self.token.Disable()
				self.users.Disable()
			else:
				self.telegram.SetValue(False)
				self.token.SetValue('')
				self.users.SetValue('')
				self.token.Enable()
				self.users.Enable()

	def edit_credentials(self, add, remove):
		save = False
		credentials = self.read_credentials()
		if add:
			for i in add:
				credentials[i] = add[i]
				save = True
		if remove:
			credentials2 = {}
			for i in credentials:
				if i in remove: save = True
				else: credentials2[i] = credentials[i]
		else: credentials2 = credentials
		if save: self.write_credentials(credentials2)

	def write_credentials(self, credentials):
		try:
			data = ujson.dumps(credentials, indent=4)
			with open(self.cred_file, "w") as outfile:
				outfile.write(data)
		except: print "ERROR writing credentials file"

	def on_localmqtt(self, e):
		if self.localmqtt.GetValue():
			if self.userlocalmqtt.GetValue() and self.passlocalmqtt.GetValue():
				self.userlocalmqtt.Disable()
				self.passlocalmqtt.Disable()
			else:
				self.ShowStatusBarRED(_('Fill in all the fields.'))
				self.localmqtt.SetValue(False)
		else:
			self.userlocalmqtt.Enable()
			self.passlocalmqtt.Enable()

	def on_remotemqtt(self, e):
		if self.remotemqtt.GetValue():
			if self.serverremotemqtt.GetValue() and self.userremotemqtt.GetValue() and self.passremotemqtt.GetValue():
				self.serverremotemqtt.Disable()
				self.portremotemqtt.Disable()
				self.userremotemqtt.Disable()
				self.passremotemqtt.Disable()
			else:
				self.ShowStatusBarRED(_('Fill in all the fields.'))
				self.remotemqtt.SetValue(False)
		else:
			self.serverremotemqtt.Enable()
			self.portremotemqtt.Enable()
			self.userremotemqtt.Enable()
			self.passremotemqtt.Enable()

	def on_twitter(self, e):
		if self.twitter.GetValue():
			if self.twitteraccount.GetValue() and self.apikey.GetValue() and self.apisecretkey.GetValue() and self.accesstoken.GetValue() and self.accesstokensecret.GetValue():
				self.twitteraccount.Disable()
				self.apikey.Disable()
				self.apisecretkey.Disable()
				self.accesstoken.Disable()
				self.accesstokensecret.Disable()
			else:
				self.ShowStatusBarRED(_('Fill in all the fields.'))
				self.twitter.SetValue(False)
		else:
			self.twitteraccount.Enable()
			self.apikey.Enable()
			self.apisecretkey.Enable()
			self.accesstoken.Enable()
			self.accesstokensecret.Enable()

	def on_telegram(self, e):
		if self.telegram.GetValue():
			if self.token.GetValue() and self.users.GetValue():
				self.token.Disable()
				self.users.Disable()
			else:
				self.ShowStatusBarRED(_('Fill in all the fields.'))
				self.telegram.SetValue(False)
		else:
			self.token.Enable()
			self.users.Enable()

	def on_apply_changes_credentials(self, e):
		add_nodes = []
		remove_ids = []
		add_credentials = {}
		remove_credentials = []
		if self.localmqtt.GetValue():
			subprocess.call(['sudo', 'sh', '-c', 'echo "' + self.userlocalmqtt.GetValue() + ':' + self.passlocalmqtt.GetValue() + '" > /etc/mosquitto/passwd.pw'])
			subprocess.call(['sudo', 'mosquitto_passwd', '-U', '/etc/mosquitto/passwd.pw'])
			subprocess.call(['sudo', 'service', 'mosquitto', 'restart'])

			localbroker_node_template = '''
		    {
		        "id": "",
		        "type": "mqtt-broker",
		        "z": "",
		        "name": "configuration|localbroker",
		        "broker": "localhost",
		        "port": "1883",
		        "clientid": "",
		        "usetls": false,
		        "compatmode": true,
		        "keepalive": "60",
		        "cleansession": true,
		        "birthTopic": "",
		        "birthQos": "0",
		        "birthPayload": "",
		        "closeTopic": "",
		        "closeQos": "0",
		        "closePayload": "",
		        "willTopic": "",
		        "willQos": "0",
		        "willPayload": ""
		    }'''
			localbroker_node = ujson.loads(localbroker_node_template)
			localbroker_node['id'] = self.localbrokerid
			add_credentials[self.localbrokerid] = {"user":self.userlocalmqtt.GetValue(),"password":self.passlocalmqtt.GetValue()}
			add_nodes.append(localbroker_node)
			self.conf.set('CREDENTIALS', 'local_mqtt', '1')
		else: 
			remove_ids.append(self.localbrokerid)
			remove_credentials.append(self.localbrokerid)
			self.conf.set('CREDENTIALS', 'local_mqtt', '0')

		if self.remotemqtt.GetValue():
			remotebroker_node_template = '''
		    {
		        "id": "",
		        "type": "mqtt-broker",
		        "z": "",
		        "name": "configuration|remotebroker",
		        "broker": "",
		        "port": "",
		        "clientid": "",
		        "usetls": false,
		        "compatmode": true,
		        "keepalive": "60",
		        "cleansession": true,
		        "birthTopic": "",
		        "birthQos": "0",
		        "birthPayload": "",
		        "closeTopic": "",
		        "closeQos": "0",
		        "closePayload": "",
		        "willTopic": "",
		        "willQos": "0",
		        "willPayload": ""
		    }'''
			remotebroker_node = ujson.loads(remotebroker_node_template)
			remotebroker_node['id'] = self.remotebrokerid
			remotebroker_node['broker'] = self.serverremotemqtt.GetValue()
			remotebroker_node['port'] = str(self.portremotemqtt.GetValue())
			add_credentials[self.remotebrokerid] = {"user":self.userremotemqtt.GetValue(),"password":self.passremotemqtt.GetValue()}
			add_nodes.append(remotebroker_node)
			self.conf.set('CREDENTIALS', 'remote_mqtt', '1')
		else: 
			remove_ids.append(self.remotebrokerid)
			remove_credentials.append(self.remotebrokerid)
			self.conf.set('CREDENTIALS', 'remote_mqtt', '0')

		if self.twitter.GetValue():
			twitter_node_template = '''
		        {
			        "id":"",
			        "type":"twitter-credentials",
			        "z":"",
			        "screen_name":""
			    }'''
			twitter_node = ujson.loads(twitter_node_template)
			twitter_node['id'] = self.twitterid
			twitter_node['screen_name'] = self.twitteraccount.GetValue()
			add_credentials[self.twitterid] = {"consumer_key":self.apikey.GetValue(),"consumer_secret":self.apisecretkey.GetValue(),"access_token":self.accesstoken.GetValue(),"access_token_secret":self.accesstokensecret.GetValue()}
			add_nodes.append(twitter_node)
			self.conf.set('CREDENTIALS', 'twitter', '1')
		else: 
			remove_ids.append(self.twitterid)
			remove_credentials.append(self.twitterid)
			self.conf.set('CREDENTIALS', 'twitter', '0')

		if self.telegram.GetValue():
			telegram_node_template = '''
				{
				    "id":"",
				    "type":"chatbot-telegram-node",
				    "z":"",
				    "usernames":"",
				    "botname":"",
				    "parseMode":"",
				    "providerToken":"",
				    "log":"",
				    "polling":"1000",
				    "debug":false,
				    "store":""
				}'''
			start1_node_template = '''
			    {
			        "id": "",
			        "type": "chatbot-telegram-receive",
			        "z": "",
			        "bot": "",
			        "botProduction": "",
			        "x": 380,
			        "y": 120,
			        "wires": [[]]
			    }'''
			start2_node_template = '''
			    {
			        "id": "",
			        "type": "chatbot-authorized",
			        "z": "",
			        "x": 380,
			        "y": 120,
			        "wires": [[],[]]
			    }'''
			start3_node_template = '''
			    {
			        "id": "",
			        "type": "function",
			        "z": "",
			        "name": "",
			        "func": "if (msg.payload.content=='/start'){return msg;}",
			        "outputs": 1,
			        "noerr": 0,
			        "x": 380,
			        "y": 120,
			        "wires": [[]]
			    }'''
			start4_node_template = '''
			    {
			        "id": "",
			        "type": "change",
			        "z": "",
			        "name": "",
			        "rules": [
			            {
			                "t": "set",
			                "p": "payload.content",
			                "pt": "msg",
			                "to": "'Chat ID: ' & $string(payload.chatId)",
			                "tot": "jsonata"
			            }
			        ],
			        "action": "",
			        "property": "",
			        "from": "",
			        "to": "",
			        "reg": false,
			        "x": 380,
			        "y": 120,
			        "wires": [[]]
			    }'''
			start5_node_template = '''
			    {
			        "id": "",
			        "type": "chatbot-telegram-send",
			        "z": "",
			        "bot": "",
			        "botProduction": "",
			        "track": false,
			        "passThrough": false,
			        "outputs": 0,
			        "x": 380,
			        "y": 120,
			        "wires": []
			    }'''
			telegram_node = ujson.loads(telegram_node_template)
			telegram_node['id'] = self.telegramid
			telegram_node['botname'] = 'telegrambot'
			telegram_node['usernames'] = self.users.GetValue()
			add_credentials[self.telegramid] = {"token":self.token.GetValue()}
			add_nodes.append(telegram_node)
			start5_node = ujson.loads(start5_node_template)
			start5_node['id'] = self.telegramid+'5'
			start5_node['z'] = self.actions_flow_id
			start5_node['bot'] = self.telegramid
			add_nodes.append(start5_node)
			start4_node = ujson.loads(start4_node_template)
			start4_node['id'] = self.telegramid+'4'
			start4_node['z'] = self.actions_flow_id
			start4_node['wires'] = [[start5_node['id']]]
			add_nodes.append(start4_node)
			start3_node = ujson.loads(start3_node_template)
			start3_node['id'] = self.telegramid+'3'
			start3_node['z'] = self.actions_flow_id
			start3_node['wires'] = [[start4_node['id']]]
			add_nodes.append(start3_node)
			start2_node = ujson.loads(start2_node_template)
			start2_node['id'] = self.telegramid+'2'
			start2_node['z'] = self.actions_flow_id
			start2_node['wires'] = [[start3_node['id']],[]]
			add_nodes.append(start2_node)
			start1_node = ujson.loads(start1_node_template)
			start1_node['id'] = self.telegramid+'1'
			start1_node['z'] = self.actions_flow_id
			start1_node['bot'] = self.telegramid
			start1_node['wires'] = [[start2_node['id']]]
			add_nodes.append(start1_node)
			self.conf.set('CREDENTIALS', 'telegram', '1')
		else: 
			remove_ids.append(self.telegramid)
			remove_ids.append(self.telegramid+'1')
			remove_ids.append(self.telegramid+'2')
			remove_ids.append(self.telegramid+'3')
			remove_ids.append(self.telegramid+'4')
			remove_ids.append(self.telegramid+'5')
			remove_credentials.append(self.telegramid)
			self.conf.set('CREDENTIALS', 'telegram', '0')

		self.edit_credentials(add_credentials, remove_credentials)
		self.nodes.edit_flow(add_nodes, remove_ids)
		self.print_credentials()
		self.restart_SK()
		seconds = 15
		for i in range(seconds, 0, -1):
			self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Starting Node-Red... ')+str(i))
			time.sleep(1)
		self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Node-Red restarted'))

	def on_cancel_changes_credentials(self, e):
		self.print_credentials()

	def on_help_credentials(self, e):
		url = self.currentpath+"/docs/html/credentials/what_are_credentials.html"
		webbrowser.open(url, new=2)

	######################################Actions

	def page_action(self):
		self.list_triggers = CheckListCtrl(self.p_action, -1,90)
		self.list_triggers.InsertColumn(0, _('Triggers'), width=100)
		self.list_triggers.InsertColumn(1, _(' '), width= 130)
		self.list_triggers.InsertColumn(2, _(' '), width= 130)
		self.list_triggers.InsertColumn(3, _(' '), width= 130)
		self.list_triggers.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_print_conditions)
		self.list_triggers.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.on_deselected_triggers)
		self.list_triggers.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.on_edit_triggers)
		self.list_triggers.OnCheckItem = self.on_check_item

		self.available_triggers = [
		_('Signal K key'), 
		_('Geofence'), 
		'GPIO', 
		'MQTT topic', 
		_('Telegram message'), 
		_('Time')]

		self.available_triggers_select = wx.Choice(self.p_action, choices=self.available_triggers, style=wx.CB_READONLY)

		add_trigger = wx.Button(self.p_action, label=_('add'))
		add_trigger.Bind(wx.EVT_BUTTON, self.on_add_trigger)

		delete_trigger = wx.Button(self.p_action, label=_('delete'))
		delete_trigger.Bind(wx.EVT_BUTTON, self.on_delete_trigger)

		self.available_operators = ['eq', 'neq', 'lt', 'lte', 'gt', 'gte','btwn', 'cont', 'true', 'false', 'null', 'nnull', 'empty', 'nempty']
		self.available_conditions = ['=', '!=', '<', '<=', '>', '>=', _('is between'), _('contains'), _('is true'), ('is false'), _('is null'), _('is not null'), _('is empty'), _('is not empty')]
		#self.available_operators_select = wx.Choice(self.p_action, choices=self.available_conditions, style=wx.CB_READONLY)

		self.list_conditions = wx.ListCtrl(self.p_action, style=wx.LC_REPORT | wx.SUNKEN_BORDER, size=(-1,90))
		self.list_conditions.InsertColumn(0, _('Conditions'), width= 100)
		self.list_conditions.InsertColumn(1, _(' '), width= 150)
		self.list_conditions.InsertColumn(2, _(' '), width= 150)
		self.list_conditions.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_print_actions)
		self.list_conditions.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.on_deselected_conditions)
		self.list_conditions.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_conditions)


		add_condition = wx.Button(self.p_action, label=_('add'))
		add_condition.Bind(wx.EVT_BUTTON, self.on_add_condition)

		delete_condition = wx.Button(self.p_action, label=_('delete'))
		delete_condition.Bind(wx.EVT_BUTTON, self.on_delete_condition)

		self.list_actions = wx.ListCtrl(self.p_action, style=wx.LC_REPORT | wx.SUNKEN_BORDER, size=(-1,90))
		self.list_actions.InsertColumn(0, _('Actions'), width= 150)
		self.list_actions.InsertColumn(1, _(' '), width= 170)
		self.list_actions.InsertColumn(2, _(' '), width= 100)
		self.list_actions.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_select_actions)
		self.list_actions.Bind(wx.EVT_LIST_ITEM_DESELECTED, self.on_deselected_actions)
		self.list_actions.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_actions)

		self.available_actions = [
		_('Set Signal K key'),
		_('Set GPIO output'),
		_('Set MQTT topic'),
		_('Publish on Twitter'),
		_('Send e-mail'),
		_('Play sound'),
		_('Run command'),
		_('Reset system'),
		_('Shutdown system'),
		_('Send Telegram message')]

		self.available_actions_select = wx.Choice(self.p_action, choices=self.available_actions, style=wx.CB_READONLY)
		add_action = wx.Button(self.p_action, label=_('add'))
		add_action.Bind(wx.EVT_BUTTON, self.on_add_action)

		delete_action = wx.Button(self.p_action, label=_('delete'))
		delete_action.Bind(wx.EVT_BUTTON, self.on_delete_action)

		help_button = wx.BitmapButton(self.p_action, bitmap=self.help_bmp, size=(self.help_bmp.GetWidth()+40, self.help_bmp.GetHeight()+10))
		help_button.Bind(wx.EVT_BUTTON, self.on_help_action)

		apply_changes = wx.Button(self.p_action, label=_('Apply changes'))
		apply_changes.Bind(wx.EVT_BUTTON, self.on_apply_changes_actions)
		cancel_changes = wx.Button(self.p_action, label=_('Cancel changes'))
		cancel_changes.Bind(wx.EVT_BUTTON, self.on_cancel_changes_actions)

		hlistbox_but = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox_but.Add(add_trigger, 0, wx.ALL, 5)
		hlistbox_but.Add(delete_trigger, 0, wx.ALL, 5)

		vlistbox_trig = wx.BoxSizer(wx.VERTICAL)
		vlistbox_trig.Add(self.available_triggers_select, 0, wx.ALL | wx.EXPAND, 5)
		vlistbox_trig.Add(hlistbox_but, 0, wx.ALL, 0)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_triggers, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox.Add(vlistbox_trig, 0, wx.RIGHT | wx.LEFT, 0)

		hlistbox_but2 = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox_but2.Add(add_condition, 0, wx.ALL, 5)
		hlistbox_but2.Add(delete_condition, 0, wx.ALL, 5)

		vlistbox_cond = wx.BoxSizer(wx.VERTICAL)
		vlistbox_cond.AddSpacer(35)
		#vlistbox_cond.Add(self.available_operators_select, 0, wx.ALL | wx.EXPAND, 5)
		vlistbox_cond.Add(hlistbox_but2, 0, wx.ALL, 0)

		hlistbox2 = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox2.Add(self.list_conditions, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox2.Add(vlistbox_cond, 0, wx.RIGHT | wx.LEFT, 0)

		hlistbox_but3 = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox_but3.Add(add_action, 0, wx.ALL, 5)
		hlistbox_but3.Add(delete_action, 0, wx.ALL, 5)

		vlistbox_act = wx.BoxSizer(wx.VERTICAL)
		vlistbox_act.Add(self.available_actions_select, 0, wx.ALL | wx.EXPAND, 5)
		vlistbox_act.Add(hlistbox_but3, 0, wx.ALL, 0)

		hlistbox3 = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox3.Add(self.list_actions, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox3.Add(vlistbox_act, 0, wx.RIGHT | wx.LEFT, 0)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(help_button, 0, wx.ALL, 0)
		hbox.AddStretchSpacer(1)
		hbox.Add(apply_changes, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(cancel_changes, 0, wx.RIGHT | wx.LEFT, 5)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hlistbox2, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hlistbox3, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5)

		self.p_action.SetSizer(vbox)

	def read_triggers(self):
		self.actions_flow_id = 'openplot.actio'
		self.selected_trigger = -1
		self.selected_condition = -1
		self.selected_action = -1
		self.nodes = Nodes(self,self.actions_flow_id)
		result = self.nodes.get_flow()
		self.actions_flow_tree = result[0]
		self.triggers_flow_nodes = result[1]
		self.conditions_flow_nodes = result[2]
		self.actions_flow_nodes = result[3]
		self.no_actions_nodes = result[4]
		self.add_credentials = {}
		self.remove_credentials = []
		self.on_print_triggers()

	def on_print_triggers(self):	
		self.list_triggers.DeleteAllItems()
		self.list_conditions.DeleteAllItems()
		self.list_actions.DeleteAllItems()
		self.selected_trigger = -1
		self.selected_condition = -1
		self.selected_action = -1
		for trigger in self.actions_flow_tree:
			enabled = False
			name = "t|"+trigger["trigger_node_out_id"]+"|"+trigger["type"]
			field2 = ''
			field3 = ''
			field4 = ''
			path = ''
			path_property = ''
			for node in self.triggers_flow_nodes:
				if 'name' in node and name == node['name']:
					if trigger["type"] == '0':
						if node['type'] == 'signalk-subscribe': 
							path = node['path']
							field2 = node['context']
							field4 = node['source']
						if node['type'] == 'function' and node['func'] and node['func'] != 'return msg;':
							items = node['func'].split(';')
							items2 = items[0].split('.')
							path_property = ':'+items2[-1]
						field3 = path+path_property
					if trigger["type"] == '1' and node['type'] == 'signalk-geofence': 
						field2 = node['context']
						if node['myposition']: field3 = _('Use My Position')
						else: field3 = node['lat']+', '+node['lon']
						field4 = node['distance']
					if trigger["type"] == '2' and node['type'] == 'rpi-gpio in': 
						field2 = node['pin']
						field3 = node['intype']
						if node['read']: field4 = _('initial state')
					if trigger["type"] == '3' and node['type'] == 'mqtt in':
						if node['broker'] == self.localbrokerid: field2 = _('local broker')
						elif node['broker'] == self.remotebrokerid: field2 = _('remote broker')
						field3 = node['topic']
					if trigger["type"] == '5' and node['type'] == 'inject':
						field2 = node['repeat']
						field3 = _('Seconds')
				if node['id'] == trigger["trigger_node_out_id"]: 
					if 	node['func'] == 'return msg;': enabled = True
			self.list_triggers.Append([self.available_triggers[int(trigger["type"])].decode('utf8'), field2.decode('utf8'), field3.decode('utf8'), field4.decode('utf8')])
			last = self.list_triggers.GetItemCount()-1
			if enabled: self.list_triggers.CheckItem(last)

	def on_check_item(self, index, flag):
		trigger_node_out_id = self.actions_flow_tree[index]['trigger_node_out_id']
		for node in self.triggers_flow_nodes:
			if node['id'] == trigger_node_out_id:
				if flag: node['func'] = 'return msg;'
				else: node['func'] = ''

	def on_print_conditions(self, e):
		self.list_conditions.DeleteAllItems()
		self.list_actions.DeleteAllItems()
		self.selected_condition = -1
		self.selected_action = -1
		self.selected_trigger = self.list_triggers.GetFirstSelected()
		if self.selected_trigger == -1: return
		conditions = self.actions_flow_tree[self.selected_trigger]["conditions"]
		triggertype = self.actions_flow_tree[self.selected_trigger]["type"]
		for condition in conditions:
			name = "c|"+condition["condition_node_out_id"]+"|"+condition["operator"]
			field2 = ''
			field3 = ''
			for node in self.conditions_flow_nodes:
				if 'name' in node and name == node['name']:
					if node['type'] == 'switch':
						if 'v' in node['rules'][0]:
							if triggertype == '5':
								try:
									seconds = float(node['rules'][0]['v'])/1000
									local_time = datetime.fromtimestamp(seconds)
									field2 = local_time.strftime("%Y-%m-%d %H:%M:%S")
								except: pass
							else: field2 = node['rules'][0]['v']
						if 't' in node['rules'][0] and node['rules'][0]['t'] == 'btwn':
							if 'v2' in node['rules'][0]:
								if triggertype == '5':
									try:
										seconds = float(node['rules'][0]['v2'])/1000
										local_time = datetime.fromtimestamp(seconds)
										field3 = local_time.strftime("%Y-%m-%d %H:%M:%S")
									except: pass
								else: field3 = node['rules'][0]['v2']
			self.list_conditions.Append([self.available_conditions[int(condition["operator"])].decode('utf8'), field2.decode('utf8'), field3.decode('utf8')])

	def on_print_actions(self, e):
		self.list_actions.DeleteAllItems()
		self.selected_action = -1
		self.selected_condition = self.list_conditions.GetFirstSelected()
		if self.selected_condition == -1: return
		actions = self.actions_flow_tree[self.selected_trigger]["conditions"][self.selected_condition]["actions"]
		for action in actions:
			name = "a|"+action["action_node_out_id"]+"|"+action["type"]
			field2 = ''
			field3 = ''
			for node in self.actions_flow_nodes:
				namenode = ''
				if 'dname' in node: namenode = node['dname']
				elif 'name' in node: namenode = node['name']
				if name == namenode:
					if action["type"] == '0' and node['type'] == 'change': 
						field2 = node['rules'][0]['to']
						field3 = node['rules'][1]['to']
					if action["type"] == '1': 
						if node['type'] == 'rpi-gpio out': field2 = node['pin']
						if node['type'] == 'change': field3 = node['rules'][0]['to']
					if action["type"] == '2':
						if node['type'] == 'mqtt out':
							if node['broker'] == self.localbrokerid: field2 = _('local broker')
							elif node['broker'] == self.remotebrokerid: field2 = _('remote broker')
							field3 = node['topic']
					if action["type"] == '3':
						if node['type'] == 'template': field2 = node['template']
						if node['type'] == 'msg-resend': field3 = _('repeat')
						if node['type'] == 'delay': field3 = _('rate limit')
					if action["type"] == '4':
						if node['type'] == 'template' and node['field'] == 'topic': field2 = node['template']
						if node['type'] == 'msg-resend': field3 = _('repeat')
						if node['type'] == 'delay': field3 = _('rate limit')
					if action["type"] == '5':
						if node['type'] == 'exec': field2 = node['append']
						if node['type'] == 'msg-resend': field3 = _('repeat')
						if node['type'] == 'delay': field3 = _('rate limit')
					if action["type"] == '6' or action["type"] == '7' or action["type"] == '8':
						if node['type'] == 'exec': 
							field2 = node['command']
							field2 += ' '+node['append']
						if node['type'] == 'msg-resend': field3 = _('repeat')
						if node['type'] == 'delay': field3 = _('rate limit')
					if action["type"] == '9':
						if node['type'] == 'template': field2 = node['template']
						if node['type'] == 'usbcamera': field2 = _('take picture')
						if node['type'] == 'chatbot-image' and not field2: field2 = node['image']
						if node['type'] == 'msg-resend': field3 = _('repeat')
						if node['type'] == 'delay': field3 = _('rate limit')
			self.list_actions.Append([self.available_actions[int(action["type"])].decode('utf8'), field2.decode('utf8'), field3.decode('utf8')])

	def on_select_actions(self, e):
		self.selected_action = self.list_actions.GetFirstSelected()

	def on_deselected_triggers(self, e):
		self.on_print_triggers()

	def on_deselected_conditions(self, e):
		self.on_print_conditions(0)

	def on_deselected_actions(self, e):
		self.selected_action = -1

	def on_edit_triggers(self, e):
		if self.selected_trigger == -1: return
		node = self.actions_flow_tree[self.selected_trigger]['trigger_node_out_id']
		triggertype = self.actions_flow_tree[self.selected_trigger]['type']
		name = 't|'+node+'|'+triggertype
		edit = []
		for i in self.triggers_flow_nodes:
			if 'name' in i:
				if i['name'] == name: edit.append(i)
			else:
				subid0 = i['id'].split('.')
				subid = subid0[0]
				for ii in self.triggers_flow_nodes:
					subid0 = ii['id'].split('.')
					subid2 = subid0[0]
					if subid2 == subid and name == ii['name']: edit.append(i)
		self.edit_add_trigger(edit)

	def on_add_trigger(self, e):
		self.edit_add_trigger(0)

	def edit_add_trigger(self, edit):
		if not edit: trigger = self.available_triggers_select.GetSelection()
		else: trigger = int(self.actions_flow_tree[self.selected_trigger]['type'])
		if trigger == 0: dlg = TriggerSK(self,edit,trigger)
		elif trigger == 1: dlg = TriggerGeofence(self,edit,trigger)
		elif trigger == 2: dlg = TriggerGPIO(self,edit,trigger)
		elif trigger == 3:
			local =  int(self.conf.get('CREDENTIALS', 'local_mqtt'))
			remote =  int(self.conf.get('CREDENTIALS', 'remote_mqtt'))
			if not local and not remote:
				self.ShowStatusBarRED(_('Go to the Credentials tab and enable at least one MQTT broker'))
				return
			else: dlg = TriggerMQTT(self,edit,local,remote,trigger)
		elif trigger == 4:
			telegram =  int(self.conf.get('CREDENTIALS', 'telegram'))
			if not telegram:
				self.ShowStatusBarRED(_('Go to the Credentials tab and enable a Telegram bot'))
				return
			else: 
				if edit: return
				else: dlg = TriggerTelegram(self,trigger)
		elif trigger == 5: dlg = TriggerTime(self,edit,trigger)
		else:
			self.ShowStatusBarRED(_('Select a trigger type.'))
			return
		res = dlg.ShowModal()
		if res == wx.OK:
			if not edit:
				for i in dlg.TriggerNodes:
					self.triggers_flow_nodes.append(i)
					if 'name' in i: items = i['name'].split('|')
				self.actions_flow_tree.append({"trigger_node_out_id": items[1],"type": items[2],"conditions": []})
				self.on_print_triggers()
				last = self.list_triggers.GetItemCount()-1
				self.list_triggers.Select(last)
			else:
				tmplist = []
				nodeout = self.actions_flow_tree[self.selected_trigger]['trigger_node_out_id']
				for i in self.triggers_flow_nodes:
					exist = False
					for ii in edit:
						if i['id'] == ii['id']: 
							exist = True
							if ii['id'] == nodeout: wires = ii['wires']
					if not exist: tmplist.append(i)
				self.triggers_flow_nodes = tmplist
				for i in dlg.TriggerNodes:
					if 'name' in i: items = i['name'].split('|')
					self.triggers_flow_nodes.append(i)
				for i in self.triggers_flow_nodes:
					if i['id'] == items[1]: i['wires'] = wires
				self.actions_flow_tree[self.selected_trigger]['trigger_node_out_id'] = items[1]
				self.actions_flow_tree[self.selected_trigger]['type'] = items[2]
				selected_trigger = self.selected_trigger
				self.on_print_triggers()
				self.selected_trigger = selected_trigger
				self.list_triggers.Select(self.selected_trigger)
		dlg.Destroy()

	def edit_conditions(self, e):
		#find connected condition
		if self.selected_condition == -1: return
		nodec = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['condition_node_out_id']
		typec = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['operator']
		name = 'c|'+nodec+'|'+typec
		edit = ''
		for i in self.conditions_flow_nodes:
			if 'name' in i:
				if i['name'] == name: 
					edit = i['rules'][0]
				self.edit_cond = i
		self.edit_add_condition(edit)

	def on_add_condition(self, e):
		self.edit_add_condition(0)

	def edit_add_condition(self, edit):
		if not edit:
			if self.selected_trigger == -1:
				self.ShowStatusBarRED(_('Select a trigger.'))
				return
		dlg = Condition(self,edit)
			
		res = dlg.ShowModal()
		if res == wx.OK:
			if not edit:
				self.conditions_flow_nodes.append(dlg.ConditionNode)
				items = dlg.ConditionNode['name'].split('|')
				self.actions_flow_tree[self.selected_trigger]['conditions'].append({"condition_node_out_id": items[1],"operator": items[2],"actions": []})
				trigger_id = self.actions_flow_tree[self.selected_trigger]['trigger_node_out_id']
				for i in self.triggers_flow_nodes:
					if i['id'] == trigger_id: i['wires'][0].append(dlg.connector_id)
				self.on_print_conditions(0)
				last = self.list_conditions.GetItemCount()-1
				self.list_conditions.Select(last)
			else:
				self.edit_cond['rules'] = dlg.ConditionNode['rules']
				namesplit = self.edit_cond['name'].split('|')
				operator = self.available_operators.index(self.edit_cond['rules'][0]['t'])
				self.edit_cond['name'] = namesplit[0]+'|'+namesplit[1]+'|'+str(operator)

				for i in self.actions_flow_tree[self.selected_trigger]['conditions']:
					if 'condition_node_out_id' in i:
						if i['condition_node_out_id'] == namesplit[1]:
							i['operator'] = str(operator)
						
				self.on_print_conditions(0)
				last = self.list_conditions.GetItemCount()-1
				self.list_conditions.Select(last)

		dlg.Destroy()

	def edit_actions(self, e):
		pass

	def on_add_action(self, e):
		self.edit_add_action(0)

	def edit_add_action(self, edit):
		if self.selected_condition == -1:
			self.ShowStatusBarRED(_('Select a condition.'))
			return
		action = self.available_actions_select.GetSelection()
		if action == 0: dlg = ActionSetSignalkKey(self,edit)
		elif action == 1: dlg = ActionSetGPIO(self,edit)
		elif action == 2:
			local =  int(self.conf.get('CREDENTIALS', 'local_mqtt'))
			remote =  int(self.conf.get('CREDENTIALS', 'remote_mqtt'))
			if not local and not remote:
				self.ShowStatusBarRED(_('Go to the Credentials tab and enable at least one MQTT broker'))
				return
			else: dlg = ActionSetMQTT(self,edit,local,remote)
		elif action == 3:
			twitter =  int(self.conf.get('CREDENTIALS', 'twitter'))
			if not twitter:
				self.ShowStatusBarRED(_('Go to the Credentials tab and enable the Twitter account'))
				return
			else: dlg = ActionPublishTwitter(self,edit)
		elif action == 4: dlg = ActionSendEmail(self,edit)
		elif action == 5: dlg = ActionPlaySound(self,edit)
		elif action == 6: dlg = ActionRunCommand(self,edit)
		elif action == 7: dlg = ActionRunCommand(self,['sudo','reboot',0])
		elif action == 8: dlg = ActionRunCommand(self,['sudo', 'shutdown -h now',0])
		elif action == 9:
			telegram =  int(self.conf.get('CREDENTIALS', 'telegram'))
			if not telegram:
				self.ShowStatusBarRED(_('Go to the Credentials tab and enable a Telegram bot'))
				return
			else: dlg = ActionSendTelegram(self,edit)
		else:
			self.ShowStatusBarRED(_('Select an action.'))
			return
		res = dlg.ShowModal()
		if res == wx.OK:
			if not edit:
				for i in dlg.ActionNodes:
					self.actions_flow_nodes.append(i)
					if 'dname' in i: items = i['dname'].split('|')
					elif 'name' in i: items = i['name'].split('|')
				self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['actions'].append({"action_node_out_id": items[1],"type": items[2]})
				condition_id = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['condition_node_out_id']
				for i in self.conditions_flow_nodes:
					if i['id'] == condition_id: i['wires'][0].append(dlg.connector_id)
				self.on_print_actions(0)
				last = self.list_actions.GetItemCount()-1
				self.list_actions.Select(last)
			else:
				pass
			if dlg.credentials:
				for i in dlg.credentials:
					self.add_credentials[i] = dlg.credentials[i]
		dlg.Destroy()

	def on_delete_trigger(self, e):
		if self.selected_trigger == -1:
			self.ShowStatusBarRED(_('Select an item to delete'))
			return
		node = self.actions_flow_tree[self.selected_trigger]['trigger_node_out_id']
		triggertype = self.actions_flow_tree[self.selected_trigger]['type']
		name = 't|'+node+'|'+triggertype
		conditions = self.actions_flow_tree[self.selected_trigger]['conditions']

		for condition in conditions:
			nodec = condition['condition_node_out_id']
			operatortype = condition['operator']
			namec = 'c|'+nodec+'|'+operatortype
			actions = condition['actions']
			for action in actions:
				nameaction = 'a|'+action['action_node_out_id']+'|'+action['type']
				self.delete_action_nodes(nameaction,action['type'],nodec)
			self.delete_condition_nodes(namec,node)

		self.delete_trigger_nodes(name)
		del self.actions_flow_tree[self.selected_trigger]
		self.on_print_triggers()

	def delete_trigger_nodes(self,name):
		tmplist = []
		for i in self.triggers_flow_nodes:
			name2 = ''
			if 'name' in i: name2 = i['name']
			elif not 'name' in i:
				subid0 = i['id'].split('.')
				subid = subid0[0]
				for ii in self.triggers_flow_nodes:
					subidii = ii['id'].split('.')
					if 'name' in ii and subid == subidii[0]: name2 = ii['name']
			if name != name2: tmplist.append(i)
		self.triggers_flow_nodes = tmplist

	def on_delete_condition(self, e):
		if self.selected_condition == -1:
			self.ShowStatusBarRED(_('Select an item to delete'))
			return
		node = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['condition_node_out_id']
		operatortype = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['operator']
		name = 'c|'+node+'|'+operatortype
		triggernode = self.actions_flow_tree[self.selected_trigger]['trigger_node_out_id']
		actions = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['actions']
		for i in actions:
			nameaction = 'a|'+i['action_node_out_id']+'|'+i['type']
			self.delete_action_nodes(nameaction,i['type'],node)
		self.delete_condition_nodes(name,triggernode)
		del self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]
		self.on_print_conditions(0)

	def delete_condition_nodes(self,name,triggernode):
		tmplist = []
		for i in self.conditions_flow_nodes:
			name2 = ''
			if 'name' in i: name2 = i['name']
			if name != name2: tmplist.append(i)
			else:
				for ii in self.triggers_flow_nodes:
					if ii['id'] == triggernode:
						if i['id'] in ii['wires'][0]: ii['wires'][0].remove(i['id'])
		self.conditions_flow_nodes = tmplist

	def on_delete_action(self, e):
		if self.selected_action == -1:
			self.ShowStatusBarRED(_('Select an item to delete'))
			return
		node = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['actions'][self.selected_action]['action_node_out_id']
		actiontype = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['actions'][self.selected_action]['type']
		name = 'a|'+node+'|'+actiontype
		conditionnode = self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['condition_node_out_id']
		self.delete_action_nodes(name,actiontype,conditionnode)
		del self.actions_flow_tree[self.selected_trigger]['conditions'][self.selected_condition]['actions'][self.selected_action]
		self.on_print_actions(0)
		
	def delete_action_nodes(self,name,actiontype,conditionnode):
		tmplist = []
		for i in self.actions_flow_nodes:
			name2 = ''
			if 'dname' in i: name2 = i['dname']
			elif 'name' in i: name2 = i['name']
			elif not 'name' in i:
				subid0 = i['id'].split('.')
				subid = subid0[0]
				for ii in self.actions_flow_nodes:
					subidii = ii['id'].split('.')
					if 'name' in ii and subid == subidii[0]: name2 = ii['name']
			if name != name2: tmplist.append(i)
			else:
				for ii in self.conditions_flow_nodes:
					if ii['id'] == conditionnode:
						if i['id'] in ii['wires'][0]: ii['wires'][0].remove(i['id'])
				if actiontype == '4' and 'type' in i:
					if i['type'] == 'e-mail': self.remove_credentials.append(i['id'])
		self.actions_flow_nodes = tmplist

	def on_apply_changes_actions(self, e):
		all_flows = []
		result = self.nodes.get_flow()
		no_actions_nodes = result[4]
		others_flow_nodes = result[5]

		for i in no_actions_nodes:
			all_flows.append(i)
		for i in others_flow_nodes:
			all_flows.append(i)
		for i in self.triggers_flow_nodes:
			all_flows.append(i)
		for i in self.conditions_flow_nodes:
			all_flows.append(i)
			if i["type"] == "switch":
				result = []
				if 'vt' in i['rules'][0] and i['rules'][0]['vt'] == 'flow':
					result = self.nodes.get_subscription(i['rules'][0]['v'])
					name = result[0]['name']
					exists = False
					for ii in all_flows:
						if 'name' in ii and ii['name'] == name: exists = True
					if not exists:
						for iii in result: all_flows.append(iii)
				if 'v2t' in i['rules'][0] and i['rules'][0]['v2t'] == 'flow':
					result = self.nodes.get_subscription(i['rules'][0]['v2'])
					name = result[0]['name']
					exists = False
					for ii in all_flows:
						if 'name' in ii and ii['name'] == name: exists = True
					if not exists:
						for iii in result: all_flows.append(iii)

		for i in self.actions_flow_nodes:
			all_flows.append(i)
			if i["type"] == "change":
				result = []
				c = len(i['rules'])
				if c == 1 and 'tot' in i['rules'][0] and i['rules'][0]['tot'] == 'flow':
					result = self.nodes.get_subscription(i['rules'][0]['to'])
				if c > 1 and 'tot' in i['rules'][1] and i['rules'][1]['tot'] == 'flow':
					result = self.nodes.get_subscription(i['rules'][1]['to'])
				if result:
					name = result[0]['name']
					exists = False
					for ii in all_flows:
						if 'name' in ii and ii['name'] == name: exists = True
					if not exists:
						for iii in result: all_flows.append(iii)
			if i["type"] == "template":
				result = []
				if 'template' in i: 
					matches = re.findall("{{(.*?)}}", i['template'])
					for ii in matches:
						value_list = ii.split('.')
						value_list.pop(0)
						skkey = '.'.join(value_list)
						result = self.nodes.get_subscription(skkey)
						name = result[0]['name']
						exists = False
						for iii in all_flows:
							if 'name' in iii and iii['name'] == name: exists = True
						if not exists:
							for iiii in result: all_flows.append(iiii)
		self.nodes.write_flow(all_flows)
		self.edit_credentials(self.add_credentials, self.remove_credentials)
		self.restart_SK()
		seconds = 15
		for i in range(seconds, 0, -1):
			self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Starting Node-Red... ')+str(i))
			time.sleep(1)
		self.ShowStatusBarGREEN(_('Signal K server restarted')+' | '+_('Node-Red restarted'))

	def on_cancel_changes_actions(self, e):
		self.read_triggers()

	def on_help_action(self, e):
		url = self.currentpath+"/docs/html/actions/what_are_actions.html"
		webbrowser.open(url, new=2)

	###########################################1W

	def page_1w(self):
		title = wx.StaticText(self.p_1w, label=_(' Temperature sensors '))

		self.list_DS18B20 = wx.ListCtrl(self.p_1w, style=wx.LC_REPORT)
		self.list_DS18B20.InsertColumn(0, _('Name'), width=100)
		self.list_DS18B20.InsertColumn(1, _('ID'), width=105)
		self.list_DS18B20.InsertColumn(2, _('Offset'), width=50)
		self.list_DS18B20.InsertColumn(3, _('Signal K key'), width=215)
		self.list_DS18B20.InsertColumn(4, _('Source'), width=120)
		self.list_DS18B20.Bind(wx.EVT_LIST_ITEM_SELECTED, self.edit_DS18B20)
		self.list_DS18B20.Bind(wx.EVT_LIST_ITEM_ACTIVATED, self.edit_DS18B20)

		add = wx.Button(self.p_1w, label=_('add'))
		add.Bind(wx.EVT_BUTTON, self.on_add_DS18B20)

		delete = wx.Button(self.p_1w, label=_('delete'))
		delete.Bind(wx.EVT_BUTTON, self.on_delete_DS18B20)

		diagnostic = wx.Button(self.p_1w, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		reset_1w = wx.Button(self.p_1w, label=_('Restart'))
		reset_1w.Bind(wx.EVT_BUTTON, self.on_reset_1w)

		hbox = wx.BoxSizer(wx.HORIZONTAL)
		hbox.Add(diagnostic, 0, wx.RIGHT | wx.LEFT, 5)
		hbox.Add(reset_1w, 0, wx.RIGHT | wx.LEFT, 5)

		hlistbox_but = wx.BoxSizer(wx.VERTICAL)
		hlistbox_but.Add(add, 0, wx.ALL, 5)
		hlistbox_but.Add(delete, 0, wx.ALL, 5)

		hlistbox = wx.BoxSizer(wx.HORIZONTAL)
		hlistbox.Add(self.list_DS18B20, 1, wx.ALL | wx.EXPAND, 5)
		hlistbox.Add(hlistbox_but, 0, wx.RIGHT | wx.LEFT, 0)

		vbox = wx.BoxSizer(wx.VERTICAL)
		vbox.Add(title, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add(hlistbox, 1, wx.ALL | wx.EXPAND, 0)
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5)

		self.p_1w.SetSizer(vbox)

	def start_1w(self):
		subprocess.Popen(['python', self.currentpath + '/1w_d.py'])
		self.ShowStatusBarGREEN(_('1W sensors restarted'))

	def stop_1w(self):
		self.ShowStatusBarRED(_('1W sensors stopped'))
		subprocess.call(['pkill', '-f', '1w_d.py'])
	
	def on_reset_1w(self, e):
		self.stop_1w()
		self.read_DS18B20()
		self.start_1w()

	def read_DS18B20(self):
		self.DS18B20 = []
		self.list_DS18B20.DeleteAllItems()
		data = self.conf.get('1W', 'DS18B20')
		try:
			temp_list = eval(data)
		except:
			temp_list = []
		for ii in temp_list:
			self.DS18B20.append(ii)
			self.list_DS18B20.Append([ii[0], ii[2], ii[3], ii[1],'1W.'+ii[0]])

	def edit_DS18B20(self, e):
		selected = e.GetIndex()
		edit = [selected, self.DS18B20[selected][0], self.DS18B20[selected][1],
				self.DS18B20[selected][2], self.DS18B20[selected][3]]
		self.edit_add_DS18B20(edit)

	def on_add_DS18B20(self, e):
		self.edit_add_DS18B20(0)

	def edit_add_DS18B20(self, edit):
                if not addDS18B20:
                	print '1-Wire must be enabled in "Raspberry Pi Configuration->Interfaces->1-Wire"'
                        app = wx.App(False)
                        wx.Frame( None, title="OpenPlotter", size=(710, 460))
                        wx.MessageBox('1-Wire must be enabled in "Raspberry Pi Configuration->Interfaces->1-Wire"', 'Warning', wx.OK | wx.ICON_WARNING)
                        return

		dlg = addDS18B20(edit)
		res = dlg.ShowModal()
		if res == wx.ID_OK:
			name = dlg.name.GetValue()
			SKkey = dlg.SKkey.GetValue()
			sensor_id = dlg.id_select.GetValue()
			offset = dlg.offset.GetValue()
			DS18B20Tmp = [name, SKkey, sensor_id, offset]
			DS18B20TmpE = [x.encode('utf-8') for x in DS18B20Tmp]
			if edit == 0:
				self.DS18B20.append(DS18B20TmpE)
			else:
				self.DS18B20[edit[0]]=DS18B20TmpE
				
			self.apply_changes_DS18B20()
		dlg.Destroy()

	def on_delete_DS18B20(self, e):
		selected_DS18B20 = self.list_DS18B20.GetFirstSelected()
		if selected_DS18B20 == -1:
			self.ShowStatusBarBLACK(_('Select an item to delete.'))
			return
		del self.DS18B20[selected_DS18B20]
		self.list_DS18B20.DeleteItem(selected_DS18B20)
		self.apply_changes_DS18B20()

	def apply_changes_DS18B20(self):
		self.conf.set('1W', 'DS18B20', str(self.DS18B20))
		self.stop_1w()
		self.start_1w()
		self.read_DS18B20()

	###########################################Serial

	def page_serial(self):
		self.list_Serialinst = wx.ListCtrl(self.p_serial, -1, style=wx.LC_REPORT | wx.SUNKEN_BORDER | wx.LC_SINGLE_SEL)
		self.list_Serialinst.InsertColumn(0, _('name'), width=85)
		self.list_Serialinst.InsertColumn(1, _('device'), width=110)
		self.list_Serialinst.InsertColumn(2, _('vendor'), width=50)
		self.list_Serialinst.InsertColumn(3, _('product'), width=55)
		self.list_Serialinst.InsertColumn(4, _('port'), width=90)
		self.list_Serialinst.InsertColumn(5, _('serial'), width=80)
		self.list_Serialinst.InsertColumn(6, _('assignment'), width=80)
		self.list_Serialinst.InsertColumn(7, _('remember'), width=75)
		self.list_Serialinst.InsertColumn(8, _('bauds'), width=60)
		self.list_Serialinst.Bind(wx.EVT_LIST_ITEM_SELECTED, self.on_SerialinstSelected)

		ttyOP_label = wx.StaticText(self.p_serial, label=_('name /dev/ttyOP_'))
		self.Serial_OPname = wx.TextCtrl(self.p_serial)
		
		assignment_label = wx.StaticText(self.p_serial, label=_('assignment'))
		self.assignment = [_('none'), 'Kplex', 'pypilot', 'CAN-USB', 'GPSD', 'NMEA 0183 out']
		self.Serial_assignment = wx.Choice(self.p_serial, choices=self.assignment, style=wx.CB_READONLY)
		self.Serial_assignment.Bind(wx.EVT_CHOICE, self.onSelectAssigment)
		self.Serial_assignment.SetSelection(0)

		bauds_label = wx.StaticText(self.p_serial, label=_('bauds'))
		self.bauds = ['','4800', '9600', '19200', '38400', '57600', '115200', '230400', '460800', '921600']
		self.Serial_baud_select = wx.Choice(self.p_serial, choices=self.bauds, style=wx.CB_READONLY)
		self.Serial_baud_select.SetSelection(0)

		self.Serial_rem_dev = wx.RadioButton(self.p_serial, label=_('Remember device (by vendor, product, serial)'))
		self.Serial_rem_port = wx.RadioButton(self.p_serial, label=_('Remember port (positon on the USB-hub)'))

		self.serial_update = wx.Button(self.p_serial, label=_('apply'))
		self.serial_update.Bind(wx.EVT_BUTTON, self.on_update_Serialinst)

		self.serial_detect = wx.Button(self.p_serial, label=_('auto'))
		self.serial_detect.Bind(wx.EVT_BUTTON, self.on_detect_Serialinst)

		self.serial_delete = wx.Button(self.p_serial, label=_('delete'))
		self.serial_delete.Bind(wx.EVT_BUTTON, self.on_delete_Serialinst)

		refresh = wx.Button(self.p_serial, label=_('refresh'))
		refresh.Bind(wx.EVT_BUTTON, self.on_refresh_Serialinst)

		enableUART = wx.Button(self.p_serial, label=_('enable UART'))
		enableUART.Bind(wx.EVT_BUTTON, self.on_enable_UART)

		disableUART = wx.Button(self.p_serial, label=_('disable UART'))
		disableUART.Bind(wx.EVT_BUTTON, self.on_disable_UART)

		row1 = wx.BoxSizer(wx.HORIZONTAL)
		row1.Add(ttyOP_label, 0, wx.UP | wx.LEFT | wx.EXPAND, 10)
		row1.Add(self.Serial_OPname, 0, wx.ALL | wx.EXPAND, 5)
		row1.Add((0,0), 1, wx.ALL | wx.EXPAND, 0)
		row1.Add(assignment_label, 0, wx.UP | wx.LEFT | wx.EXPAND, 10)
		row1.Add(self.Serial_assignment, 0, wx.ALL | wx.EXPAND, 5)
		row1.Add((0,0), 1, wx.ALL | wx.EXPAND, 0)
		row1.Add(bauds_label, 0, wx.UP | wx.LEFT | wx.EXPAND, 10)
		row1.Add(self.Serial_baud_select, 0, wx.ALL | wx.EXPAND, 5)

		col1 = wx.BoxSizer(wx.VERTICAL)
		col1.Add(self.Serial_rem_dev, 0, wx.ALL | wx.EXPAND, 5)
		col1.Add(self.Serial_rem_port, 0, wx.ALL | wx.EXPAND, 5)

		col2 = wx.BoxSizer(wx.HORIZONTAL)
		col2.Add(self.serial_detect, 0, wx.ALL | wx.EXPAND, 5)
		col2.Add(self.serial_update, 0, wx.ALL | wx.EXPAND, 5)
		col2.Add(self.serial_delete, 0, wx.ALL | wx.EXPAND, 5)

		row2 = wx.BoxSizer(wx.HORIZONTAL)
		row2.Add(col1, 1, wx.ALL | wx.EXPAND, 0)
		row2.Add(col2, 1, wx.ALL | wx.EXPAND, 0)

		row3 = wx.BoxSizer(wx.HORIZONTAL)
		row3.Add(enableUART, 0, wx.ALL | wx.EXPAND, 5)
		row3.Add(disableUART, 0, wx.ALL | wx.EXPAND, 5)
		row3.Add(refresh, 0, wx.ALL | wx.EXPAND, 5)

		v_final = wx.BoxSizer(wx.VERTICAL)
		v_final.Add(self.list_Serialinst, 1, wx.ALL | wx.EXPAND, 5)
		v_final.Add(row1, 0, wx.ALL | wx.EXPAND, 5)
		v_final.Add(row2, 0, wx.ALL | wx.EXPAND, 5)
		v_final.Add(row3, 0, wx.ALL | wx.EXPAND, 5)

		self.p_serial.SetSizer(v_final)

		self.on_SerialinstSelected()

	def start_udev(self):
		subprocess.call(['sudo', 'udevadm', 'control', '--reload-rules'])
		subprocess.call(['sudo', 'udevadm', 'trigger', '--attr-match=subsystem=tty'])

	def read_Serialinst(self):
		self.on_refresh_Serialinst()

	def on_refresh_Serialinst(self, e=0):
		self.list_Serialinst.DeleteAllItems()
		data = self.conf.get('UDEV', 'Serialinst')
		try:
			self.Serialinst = eval(data)
		except:
			self.Serialinst = {}
		sentence = 0
		try:
			self.context
		except:
			self.context = pyudev.Context()

		for device in self.context.list_devices(subsystem='tty'):
			i = device['DEVNAME']
			if not '/dev/moitessier' in i:
				try:
					ii = device['DEVLINKS']
				except:
					continue
			if not ('/dev/moitessier' in i or '/dev/ttyACM' in i or '/dev/ttyUSB' in i or '/dev/serial0' in ii):
				continue
			value = device['DEVPATH']
			port = value[value.rfind('/usb1/') + 6:-(len(value) - value.find('/tty'))]
			port = port[port.rfind('/') + 1:]
			try:
				serial = device['ID_SERIAL_SHORT']
			except:
				serial = ''
			try:
				vendor_db = device['ID_VENDOR_FROM_DATABASE']
			except:
				vendor_db = ''
			try:
				model_db = device['ID_MODEL_FROM_DATABASE']
			except:
				model_db = ''
			try:
				vendor_id = device['ID_VENDOR_ID']
			except:
				vendor_id = ''
			try:
				model_id = device['ID_MODEL_ID']
			except:
				model_id = ''

			# default values if this port is not configured
			name = ''
			assignment = _('none')
			remember = ''
			bauds = ''

			for n in self.Serialinst:
				ii = self.Serialinst[n]

				if ii['remember'] == 'port' and ii['port'] == port:
					if ii['vendor'] != vendor_id or ii['product'] != model_id or ii['serial'] != serial:
						self.ShowMessage(_('Warning: You have connected the "').decode('utf8') + vendor_id + ', ' + model_id + _('" to the usb port which is reserved for another device').decode('utf8'))
						break
					name = n
					assignment = ii['assignment']
					remember = ii['remember']
					try:
						bauds = ii['bauds']
					except:
						pass
					break
				elif ii['remember'] == 'dev' and ii['vendor'] == vendor_id and ii['product'] == model_id and ii['serial'] == serial:
					#check if device with same product/vendor/serial has been added
					exist = False
					for i2 in range(self.list_Serialinst.GetItemCount()):
						if n == self.list_Serialinst.GetItemText(i2, 0): exist = True
					if not exist:
						name = n
						assignment = ii['assignment']
						remember = ii['remember']
						try:
							bauds = ii['bauds']
						except:
							pass

			l = [name, i, vendor_id, model_id, port, serial, assignment, remember, bauds]
			self.list_Serialinst.Append(map(lambda x : x.decode('utf8'), l))
			sentence = 1

		for name in self.Serialinst:
			exist = False
			for i in range(self.list_Serialinst.GetItemCount()):
				if name == self.list_Serialinst.GetItemText(i, 0): exist = True
			if not exist:
				l = [name, self.Serialinst[name]['device'], self.Serialinst[name]['vendor'], self.Serialinst[name]['product'], self.Serialinst[name]['port'], self.Serialinst[name]['serial'], self.Serialinst[name]['assignment'], self.Serialinst[name]['remember'], self.Serialinst[name]['bauds']]
				self.list_Serialinst.Append(map(lambda x : x.decode('utf8'), l))
				self.list_Serialinst.SetItemBackgroundColour(self.list_Serialinst.GetItemCount()-1, "red")

		try:
			filesize = os.stat('/etc/udev/rules.d/10-openplotter.rules').st_size
		except:
			filesize = 0

		if sentence == 0 and filesize > 10:
			self.apply_changes_Serialinst()
		if sentence == 1 and filesize < 10:
			self.apply_changes_Serialinst()

		self.on_SerialinstSelected()

	def detect_pypilot_servo(self, device, baud):
		# try pypilot binary arduino servo
		test = os.system('sudo pypilot_servo -t ' + device + ' %d' % baud)
		if test == 0: return True
		else: return False

	def detect_gps_device(self, device):
		subprocess.call(['killall', '-9', 'gpscat'])
		gpscat = subprocess.Popen(['gpscat','-t',device], stdout=subprocess.PIPE)
		#poll = select.poll()
		#poll.register(gpscat.stdout, select.POLLOUT)
		#x = poll.poll(5000)
		#ret = x[0][1] == select.POLLOUT
		import fcntl
		fcntl.fcntl(gpscat.stdout.fileno(), fcntl.F_SETFD, os.O_NONBLOCK)
		time.sleep(3)
		ret = gpscat.stdout.readline()
		os.system('kill %d' % gpscat.pid)
		return ret

	def readNMEA0183(self, port, baudrate):
		try:
			device = serial.Serial(port, baudrate, timeout=1)
		except Exception as e:
			print str(e)
			return False
		timewait = time.time() + 1.5
		index = 0
		countwrong = 0
		text = ''
		while time.time() < timewait:
			try:
				c = device.read(1)
			except: c = ''
			if c != '':
				b = ord(c)
				# print c
				if b == 10 or b == 13 or (32 <= b < 128):
					index += 1
					if b == 13:
						#print '	' + text[:-1]
						text = ''
					elif b == 10:
						pass
					else:
						text += c
				else:
					#print 'countwrong ', b
					countwrong += 1
		if index > 10 and countwrong < index/10: return True
		else: return False

	def readNMEA2000(self, port, baudrate):
		try:
			device = serial.Serial(port, baudrate, timeout=1)
		except Exception as e:
			print str(e)
			return False
		timewait = time.time() + 0.5
		data = [0x10, 0x2, 0xa1, 0x01, 0x01, 0x5d, 0x10, 0x03]
		for i in data:
			device.write(chr(i))
		while time.time() < timewait:
			try:
				c = device.read(1)
			except: c = ''
			if c != '':
				b = ord(c)
				if b == 0x10:
					try:
						c = device.read(1)
					except: c = ''
					if c != '':
						b = ord(c)
						if b == 0x02:
							return True
		return False

	def detect_serial(self, index):
		name = self.list_Serialinst.GetItemText(index, 0)
		if not name: name = 'serial%d'%index
		device = self.list_Serialinst.GetItemText(index, 1)
		bauds = self.list_Serialinst.GetItemText(index, 8)
		if bauds: bauds = int(bauds)
		pypilot_mode = self.conf.get('PYPILOT', 'mode')

		if device == '/dev/moitessier.tty':
			assignment = 'GPSD'
			bauds = ''
		elif self.readNMEA2000(device, '115200'):
			assignment = 'CAN-USB'
			bauds = '115200'
		elif self.readNMEA2000(device, '230400'):
			assignment = 'CAN-USB'
			bauds = '230400'
		elif self.readNMEA2000(device, '460800'):
			assignment = 'CAN-USB'
			bauds = '460800'
		elif self.readNMEA2000(device, '921600'):
			assignment = 'CAN-USB'
			bauds = '921600'

		elif self.detect_pypilot_servo(device, 38400):
			assignment = 'pypilot'
			bauds = '38400'
		elif pypilot_mode == 'basic autopilot' and self.detect_gps_device(device):
			assignment = 'GPSD'
			bauds = ''
		else:
			bauds = ''
			self.bauds = ['4800', '9600', '19200', '38400', '57600', '115200', '230400', '460800']

			for i in self.bauds:
				if self.readNMEA0183(device, i):
					assignment = 'Kplex'
					bauds = i
			if not bauds: return False

		self.Serial_OPname.SetValue(name)
		self.Serial_assignment.SetStringSelection(assignment)
		self.Serial_baud_select.SetStringSelection(bauds)
		return True
                
	def on_detect_Serialinst(self, e):
		index = self.list_Serialinst.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_SELECTED)
		if index < 0:
			self.ShowMessage(_('Failed. No port selected'))
			self.on_SerialinstSelected()
			return
		self.stop_sensors()
		self.stop_kplex()
		os.system('sudo service gpsd stop')
		self.stop_SK()
		self.ShowStatusBarGREEN(_('Checking selected device ...'))
		result = self.detect_serial(index)
		os.system('sudo service gpsd start')
		self.on_restart_kplex(0)
		self.start_sensors()
		self.start_SK()
		if self.Serial_assignment.GetStringSelection() in {'Kplex','NMEA 0183 out','CAN-USB'}:
			self.Serial_baud_select.Enable()
		else:
			self.Serial_baud_select.SetSelection(0)
			self.Serial_baud_select.Disable()
		if result:
			self.ShowStatusBarGREEN(_('Suitable parameters according to your system settings. Press apply to save.'))
		else: 
			self.ShowStatusBarRED (_('We have not found any recognizable data on your device.'))

	def on_SerialinstSelected(self, e=False):
		valid = e and e.GetIndex() >= 0
		self.Serial_OPname.Enable(valid)
		self.Serial_assignment.Enable(valid)
		self.serial_detect.Enable(valid)
		self.serial_update.Enable(valid)
		self.serial_delete.Enable(valid)
		self.Serial_baud_select.Enable(valid)
		self.Serial_rem_dev.Enable(valid)
		self.Serial_rem_port.Enable(valid)
		if not valid:
			self.reset_Serial_fields()
			return

		i = e.GetIndex()
		if 'serial' in self.list_Serialinst.GetItemText(i, 4):
			self.Serial_rem_port.SetValue(True) # remember by port for non usb
			self.Serial_rem_dev.Disable()
			self.Serial_rem_port.Disable()
		else:
			rem = self.list_Serialinst.GetItemText(i, 7)
			self.Serial_rem_dev.SetValue(rem == 'dev')
			self.Serial_rem_port.SetValue(rem == 'port')

		self.Serial_OPname.SetValue(self.list_Serialinst.GetItemText(i, 0))
		self.Serial_assignment.SetStringSelection(self.list_Serialinst.GetItemText(i, 6))
		self.Serial_baud_select.SetStringSelection(self.list_Serialinst.GetItemText(i, 8))

		if self.Serial_assignment.GetStringSelection() in {'Kplex','NMEA 0183 out','CAN-USB'}:
			self.Serial_baud_select.Enable()
		else:
			self.Serial_baud_select.SetSelection(0)
			self.Serial_baud_select.Disable()

	def on_update_Serialinst(self, e=0):

		index = self.list_Serialinst.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_SELECTED)
		if index < 0:
			self.ShowMessage(_('Failed. No port selected'))
			self.on_SerialinstSelected()
			return

		name = self.Serial_OPname.GetValue()
		old_name = self.list_Serialinst.GetItemText(index, 0)

		if not name:
			self.ShowMessage(_('Failed. You have to provide a name (between 1 and 8 letters and/or numbers).'))
			return

		for i in range(self.list_Serialinst.GetItemCount()):
			if i != index and name == self.list_Serialinst.GetItemText(i, 0):
				self.ShowMessage(_('Failed. Same name used for multiple devices'))
				return

		if not re.match('^[0-9a-z]{1,8}$', name):
			self.ShowMessage(_('Failed. The new name must be a lowercase string between 1 and 8 letters and/or numbers.'))
			return


		self.list_Serialinst.SetStringItem(index, 0, name)
		assignment = self.Serial_assignment.GetStringSelection()
		bauds = self.Serial_baud_select.GetStringSelection()

		if (assignment in {'Kplex','NMEA 0183 out'}) and bauds == '':
			self.ShowMessage(_('Failed. Select bauds.'))
			return

		self.list_Serialinst.SetStringItem(index, 6, assignment)
		if self.Serial_rem_dev.GetValue():
			rem = 'dev'
		else:
			rem = 'port'
		self.list_Serialinst.SetStringItem(index, 7, rem)
		self.list_Serialinst.SetStringItem(index, 8, bauds)

		ii = {}
		cols = ['name', 'device', 'vendor', 'product', 'port', 'serial', 'assignment', 'remember', 'bauds']
		for j in range(len(cols)):
			ii[cols[j]] = self.list_Serialinst.GetItemText(index, j)
		del ii['name']

		if old_name and old_name != name: del self.Serialinst[old_name]

		# make sure there are not two ports with the same product/vendor/serial remembered by dev
		for name2 in self.Serialinst:
			if self.Serialinst[name2]['remember'] == 'dev' and ii['remember'] == 'dev' and name != name2:
				if self.Serialinst[name2]['vendor'] == ii['vendor'] and self.Serialinst[name2]['product'] == ii['product'] and self.Serialinst[name2]['serial'] == ii['serial']:
					self.ShowMessage(_('Warning: USB-Port with duplicate vendor product must be set to "Remember port".'))
					ii['remember'] = 'port'
					break

		# do not allow entrees with the same port and different name
		for name2 in self.Serialinst:
			if self.Serialinst[name2]['remember'] == 'port' and ii['remember'] == 'port' and name != name2:
				if self.Serialinst[name2]['port'] == ii['port']:
					self.ShowMessage(_('Warning: This port is already reserved and must be set to "Remember device".'))
					ii['remember'] = 'dev'
					break
		
		self.Serialinst[name] = ii

		self.conf.set('UDEV', 'Serialinst', str(self.Serialinst))
		self.on_refresh_Serialinst()
		self.Serialinst[name] = ii
		self.apply_changes_Serialinst()

	def on_delete_Serialinst(self, e):
		index = self.list_Serialinst.GetNextItem(-1, wx.LIST_NEXT_ALL, wx.LIST_STATE_SELECTED)
		if index < 0:
			self.ShowMessage(_('Failed. No port selected'))
			self.on_SerialinstSelected()
			return

		name = self.list_Serialinst.GetItemText(index, 0)
		try:
			del self.Serialinst[name]
		except: return

		self.list_Serialinst.SetStringItem(index, 0, '')
		self.list_Serialinst.SetStringItem(index, 6, _('none'))
		self.list_Serialinst.SetStringItem(index, 7, '')
		self.list_Serialinst.SetStringItem(index, 8, '')

		self.reset_Serial_fields()

		self.conf.set('UDEV', 'Serialinst', str(self.Serialinst))
		self.apply_changes_Serialinst()

	def reset_Serial_fields(self):
		self.Serial_OPname.SetValue('')
		self.Serial_rem_dev.SetValue(True)
		self.Serial_rem_port.SetValue(False)
		self.Serial_assignment.SetSelection(0)
		self.Serial_baud_select.SetSelection(0)
                                        
	def apply_changes_Serialinst(self):
		file = open(self.home +'/10-openplotter.rules', 'w')
		for name in self.Serialinst:
			i = self.Serialinst[name]
			if 'virtual' == i['port']:
				write_str = 'KERNEL=="'+i['device'][5:]
			elif 'port' == i['remember']: # non-usb serial
				write_str = 'KERNEL=="' + i['device'][5:-1] + '*", KERNELS=="' + i['port']
			else:
				write_str = 'SUBSYSTEM=="tty", ATTRS{idVendor}=="' + i['vendor']
				write_str += '",ATTRS{idProduct}=="' + i['product']
				if i['serial'] != '':
					write_str += '",ATTRS{serial}=="' + i['serial']
			write_str += '",SYMLINK+="ttyOP_' + name + '"\n'
			file.write(write_str)
		file.close()
		test = 0
		test = os.system('sudo mv '+self.home +'/10-openplotter.rules /etc/udev/rules.d')

		self.ShowStatusBarRED(_('Restarting ...'))
		self.start_udev()

		# write gpsd config
		gpsd_exists = False
		file = open('/etc/default/gpsd', 'r')
		file1 = open(self.home+'/gpsd', 'w')
		while True:
			line = file.readline()
			if not line: break
			if line[:9] == 'DEVICES="':
				file1.write('DEVICES="')
				for name in self.Serialinst:
					if self.Serialinst[name]['assignment'] == 'GPSD':
						gpsd_exists = True
						port = '/dev/ttyOP_' + name
						file1.write(port + ' ')
				file1.write('"\n')
			else: file1.write(line)
		file.close()
		file1.close()

		if os.system('diff '+self.home+'/gpsd /etc/default/gpsd > /dev/null'):
			# only restart gpsd if changed
			os.system('sudo mv '+self.home+'/gpsd /etc/default')
			os.system('sudo service gpsd restart')
		else: os.system('rm -f '+self.home+'/gpsd')

		# write pypilot allowed ports
		file = open(self.home+'/pypilot_serial_ports', 'w')
		pypilot_exists = False
		for name in self.Serialinst:
			if self.Serialinst[name]['assignment'] == 'pypilot':
				pypilot_exists = True
				port = '/dev/ttyOP_' + name
				file.write(port + '\n')
				os.system('sudo chown pi ' + port) # set permissions
		file.close()

		path = self.home + '/.pypilot/serial_ports'
		if os.system('diff '+self.home+'/pypilot_serial_ports ' + path + ' > /dev/null'):
			os.system('mv '+self.home+'/pypilot_serial_ports ' + path)
			if pypilot_exists:
				self.conf.set('PYPILOT', 'mode', 'basic autopilot')
			else:
				self.conf.set('PYPILOT', 'mode', 'disabled')
				check_imu = self.check_imu()
				if check_imu: 
					imu_data = eval(check_imu) 
					imu_name = imu_data[0][0]
					if imu_name != '0': self.conf.set('PYPILOT', 'mode', 'imu')
			self.read_pypilot()
			self.on_apply_changes_pypilot()
		else: os.system('rm -f '+self.home+'/pypilot_serial_ports')

		#set kplex devices
		self.read_kplex_conf()
		for name in self.Serialinst:
			if self.Serialinst[name]['assignment'] == 'Kplex':
				exist = False
				for index, i in enumerate(self.kplex):
					if i[1] == name:
						if i[2] != 'Serial':
							self.Serialinst[name]['assignment'] == _('none')
							self.ShowMessage(_('Failed. Same name used for multiple devices: ')+name)
						else:
							exist = True
							self.kplex[index][5] = self.Serialinst[name]['bauds']
				if not exist:
					self.kplex.append([None, name, 'Serial', 'in', 'ttyOP_'+name, self.Serialinst[name]['bauds'], 'none', 'nothing', 'none', 'nothing', '1'])
	
		#check if there is gpsd and create kplex input
		if gpsd_exists:
			exist = False
			for index, i in enumerate(self.kplex):
				if i[1] == 'gpsd': exist = True
			if not exist:
				self.kplex.append([None, 'gpsd', 'TCP', 'in', 'localhost', '2947', 'none', 'nothing', 'none', 'nothing', '1'])
		else:
			for index, i in enumerate(self.kplex):
				if i[1] == 'gpsd': 
					del self.kplex[index]
					break

		#set nmea 0183 out (put this always before clean kplex)
		nmea0183out_exists = False
		data = '[tcp]\nname=nmea0183out\ndirection=in\nmode=client\npersist=fromstart\nretry=10\naddress=localhost\nport=10110\n'
		for name in self.Serialinst:
			if self.Serialinst[name]['assignment'] == 'NMEA 0183 out':
				nmea0183out_exists = True
				data += '\n[serial]\nname='+name+'\ndirection=out\noptional=yes\nfilename=/dev/ttyOP_'+name+'\nbaud='+self.Serialinst[name]['bauds']+'\n'
		if nmea0183out_exists:
			file = open(self.home+'/.nmea0183out.conf', 'w')
			file.write(data)
			file.close()

		#clean kplex
		for index, i in enumerate(self.kplex):
			if i[2] == 'Serial':
				exist = False
				for name in self.Serialinst:
					if i[1] == name and self.Serialinst[name]['assignment'] == 'Kplex': exist = True
				if not exist: del self.kplex[index]
		self.set_list_kplex()
		self.on_apply_changes_kplex(0)

		#set CAN-USB devices
		can_device = ''
		for name in self.Serialinst:
			if self.Serialinst[name]['assignment'] == 'CAN-USB':
				self.can_device = '/dev/ttyOP_'+name
				self.can_speed = self.Serialinst[name]['bauds']
				break
		if not can_device:
			self.conf.set('N2K', 'output', '0')
			self.SK_settings.enable_disable_all(0)
		else:
			if self.SK_settings.ngt1_device != self.can_device:
				self.SK_settings.set_ngt1_device(self.can_device,self.can_speed)
		self.read_n2k()

		time.sleep(1.5)
		self.ShowStatusBarGREEN(_('Serial port modified and restarted'))

	def onSelectAssigment(self, e):
		selected = self.Serial_assignment.GetStringSelection()
		if selected == 'CAN-USB':
			for name in self.Serialinst:
				if self.Serialinst[name]['assignment'] == selected:
					self.ShowMessage(_('Failed. You can assign only one ')+selected+_(' device'))
					self.Serial_assignment.SetSelection(0)
		if selected == 'Kplex' or selected == 'NMEA 0183 out':
			self.Serial_baud_select.Clear()
			self.bauds = ['','4800', '9600', '19200', '38400', '57600', '115200', '230400', '460800']
			for i in self.bauds:
				self.Serial_baud_select.Append(i)				
		
			self.Serial_baud_select.SetSelection(1)
			self.Serial_baud_select.Enable()
		elif selected == 'CAN-USB':
			self.Serial_baud_select.Clear()
			self.bauds = ['115200', '230400', '460800', '921600']
			for i in self.bauds:
				self.Serial_baud_select.Append(i)				
			self.Serial_baud_select.SetSelection(0)
			self.Serial_baud_select.Enable()
		else:
			self.Serial_baud_select.SetSelection(0)
			self.Serial_baud_select.Disable()

	def on_enable_UART(self,e):
		msg = _('This action disables Bluetooth and enables UART. OpenPlotter will reboot.\n').decode('utf8')
		msg += _('Are you sure?').decode('utf8')
		dlg = wx.MessageDialog(None, msg, _('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_EXCLAMATION)
		if dlg.ShowModal() == wx.ID_YES: self.edit_boot(True)
		dlg.Destroy()

	def on_disable_UART(self,e):
		msg = _('This action disables UART and enables Bluetooth. OpenPlotter will reboot.\n').decode('utf8')
		msg += _('Are you sure?').decode('utf8')
		dlg = wx.MessageDialog(None, msg, _('Question'), wx.YES_NO | wx.NO_DEFAULT | wx.ICON_EXCLAMATION)
		if dlg.ShowModal() == wx.ID_YES: self.edit_boot(False)
		dlg.Destroy()

	def edit_boot(self, onoff):
		file = open('/boot/config.txt', 'r')
		file1 = open(self.home+'/config.txt', 'w')
		exists = False
		while True:
			line = file.readline()
			if not line: break
			if onoff and 'dtoverlay=pi3-disable-bt' in line: 
				file1.write('dtoverlay=pi3-disable-bt\n')
				os.system('sudo systemctl disable hciuart')
				exists = True
			elif not onoff and 'dtoverlay=pi3-disable-bt' in line: 
				file1.write('#dtoverlay=pi3-disable-bt\n')
				os.system('sudo systemctl enable hciuart')
				exists = True
			else: file1.write(line)
		if onoff and not exists: 
			file1.write('\ndtoverlay=pi3-disable-bt\n')
			os.system('sudo systemctl disable hciuart')
		file.close()
		file1.close()

		file = open('/boot/cmdline.txt', 'r')
		file1 = open(self.home+'/cmdline.txt', 'w')
		text = file.read()
		text = text.replace('\n', '')
		text_list = text.split(' ')
		if onoff and 'console=serial0,115200' in text_list: 
			text_list.remove('console=serial0,115200')
		if not onoff and not 'console=serial0,115200' in text_list: 
			text_list.append('console=serial0,115200')
		final = ' '.join(text_list)+'\n'
		file1.write(final)
		file.close()
		file1.close()

		reset = False
		if os.system('diff '+self.home+'/config.txt /boot/config.txt > /dev/null'):
			os.system('sudo mv '+self.home+'/config.txt /boot')
			reset = True
		else: os.system('rm -f '+self.home+'/config.txt')
		if os.system('diff '+self.home+'/cmdline.txt /boot/cmdline.txt > /dev/null'):
			os.system('sudo mv '+self.home+'/cmdline.txt /boot')
			reset = True
		else: os.system('rm -f '+self.home+'/cmdline.txt')

		if reset == True : os.system('sudo shutdown -r now')

	###########################################CAN

	def page_n2k(self):	
		CANUSB_label = wx.StaticText(self.p_n2k, label=_('CAN-USB device:'))
		self.can_usb = wx.StaticText(self.p_n2k)

		canboat_box = wx.StaticBox(self.p_n2k, label=_(' Managed by OpenPlotter (canboat) ')) 

		self.n2k_enable = wx.CheckBox(self.p_n2k, label=_('Input CAN-USB'))
		self.n2k_enable.Bind(wx.EVT_CHECKBOX, self.on_n2k_enable)

		self.N2K_diagnostic_b = wx.Button(self.p_n2k, label=_('Diagnostic'))
		self.N2K_diagnostic_b.Bind(wx.EVT_BUTTON, self.on_N2K_diagnostic)

		self.n2k_out_enable = wx.CheckBox(self.p_n2k, label=_('Output CAN-USB'))
		self.n2k_out_enable.Bind(wx.EVT_CHECKBOX, self.on_n2k_output)

		self.N2K_diagnostic_out_b = wx.Button(self.p_n2k, label=_('Diagnostic'))
		self.N2K_diagnostic_out_b.Bind(wx.EVT_BUTTON, self.on_N2K_diagnostic_out)
	
		self.button_N2K_setting = wx.Button(self.p_n2k, label=_('TX PGN enable list'))
		self.button_N2K_setting.Bind(wx.EVT_BUTTON, self.on_N2K_setting)
	
		self.SK_to_N2K = wx.Button(self.p_n2k, label=_('Signal K to N2K'))
		self.SK_to_N2K.Bind(wx.EVT_BUTTON, self.on_SK_to_N2K)

		diagnostic = wx.Button(self.p_n2k, label=_('SK Diagnostic'))
		diagnostic.Bind(wx.EVT_BUTTON, self.on_diagnostic_SK)

		canboatjs_box = wx.StaticBox(self.p_n2k, label=_(' Managed by Signal K (canboatjs) ')) 
		
		self.ngt1js_enabled = wx.CheckBox(self.p_n2k, label=_('Input/Output CAN-USB'))
		self.ngt1js_enabled.Bind(wx.EVT_CHECKBOX, self.on_ngt1js_enabled)		
		self.n2k_can0_enable = wx.CheckBox(self.p_n2k, label=_('Input/Output can0'))
		self.n2k_can0_enable.Bind(wx.EVT_CHECKBOX, self.on_n2k_can0_enable)	

		self.SK_to_N2K2 = wx.Button(self.p_n2k, label=_('Signal K to N2K'))
		self.SK_to_N2K2.Bind(wx.EVT_BUTTON, self.on_SK_to_N2K2)	
		
		hbox = wx.BoxSizer(wx.HORIZONTAL) 
		hbox.Add(CANUSB_label, 0, wx.ALL | wx.EXPAND, 10) 
		hbox.Add(self.can_usb, 0, wx.ALL | wx.EXPAND, 10)
		hbox.Add((0,0), 1, wx.ALL | wx.EXPAND, 5)
		hbox.Add(self.button_N2K_setting, 0, wx.ALL | wx.EXPAND, 5)

		v_boxSizer1 = wx.BoxSizer(wx.HORIZONTAL)
		v_boxSizer1.Add(self.n2k_enable, 0, wx.ALL | wx.EXPAND, 5)
		v_boxSizer1.Add(self.N2K_diagnostic_b, 0, wx.ALL | wx.EXPAND, 5)

		v_boxSizer2 = wx.BoxSizer(wx.HORIZONTAL)
		v_boxSizer2.Add(self.n2k_out_enable, 0, wx.ALL | wx.EXPAND, 5)
		v_boxSizer2.Add(self.N2K_diagnostic_out_b, 0, wx.ALL | wx.EXPAND, 5)
		v_boxSizer2.Add(self.SK_to_N2K, 0, wx.ALL | wx.EXPAND, 5)

		v_boxSizer0 = wx.StaticBoxSizer(canboat_box, wx.VERTICAL)
		v_boxSizer0.Add(v_boxSizer1, 0, wx.ALL | wx.EXPAND, 5)
		v_boxSizer0.Add(v_boxSizer2, 0, wx.ALL | wx.EXPAND, 5)

		v_boxSizer3 = wx.StaticBoxSizer(canboatjs_box, wx.HORIZONTAL) 
		v_boxSizer3.Add(self.ngt1js_enabled, 0, wx.ALL | wx.EXPAND, 5)
		v_boxSizer3.Add(self.n2k_can0_enable, 0, wx.ALL | wx.EXPAND, 5)
		v_boxSizer3.Add(self.SK_to_N2K2, 0, wx.ALL | wx.EXPAND, 5)
		
		vbox = wx.BoxSizer(wx.VERTICAL) 
		vbox.Add(hbox, 0, wx.ALL | wx.EXPAND, 5) 
		vbox.Add(v_boxSizer0, 0, wx.ALL | wx.EXPAND, 5)
		vbox.AddSpacer(10)
		vbox.Add(v_boxSizer3, 0, wx.ALL | wx.EXPAND, 5)
		vbox.Add((0,0), 1, wx.ALL | wx.EXPAND, 5)
		vbox.Add(diagnostic, 0, wx.ALL, 5) 
		self.p_n2k.SetSizer(vbox) 

	def on_SK_to_N2K(self, event):
		dlg = addSKtoN2K()
		res = dlg.ShowModal()
		dlg.Destroy()

	def on_SK_to_N2K2(self, event):
		url = "http://localhost:3000/@signalk/server-admin-ui/#/serverConfiguration/plugins"
		webbrowser.open(url, new=2)
				
	def read_n2k(self):
		self.can_device = ''
		for name in self.Serialinst:
			if self.Serialinst[name]['assignment'] == 'CAN-USB':
				self.can_device = '/dev/ttyOP_'+name
				self.can_speed = self.Serialinst[name]['bauds']
				break
		self.n2k_enable.SetValue(self.SK_settings.ngt1_enabled == 1)
		self.n2k_out_enable.SetValue(self.conf.get('N2K', 'output') == '1')
		self.ngt1js_enabled.SetValue(self.SK_settings.ngt1js_enabled == 1)

		can_exists=os.path.isdir('/sys/class/net/can0')
		if can_exists:
			self.n2k_can0_enable.Enable()
			self.n2k_can0_enable.SetValue(self.SK_settings.canbus_enabled == 1)
		else:
			self.n2k_can0_enable.Disable()
			
		if self.can_device:	
			self.can_usb.SetLabel(self.can_device)
			if self.n2k_enable.GetValue() or self.n2k_out_enable.GetValue() or self.ngt1js_enabled.GetValue():
				self.button_N2K_setting.Disable()
				self.N2K_diagnostic_b.Disable()
				self.N2K_diagnostic_out_b.Disable()
			else:
				self.button_N2K_setting.Enable()
				self.N2K_diagnostic_b.Enable()
				self.N2K_diagnostic_out_b.Enable()
			if self.n2k_enable.GetValue() or self.n2k_out_enable.GetValue():
				self.ngt1js_enabled.Disable()
				self.n2k_can0_enable.Disable()
			else:
				self.ngt1js_enabled.Enable()
				if can_exists: 
					self.n2k_can0_enable.Enable()
			if self.ngt1js_enabled.GetValue() or self.n2k_can0_enable.GetValue():
				self.n2k_enable.Disable()
				self.n2k_out_enable.Disable()
			else:
				self.n2k_enable.Enable()
				self.n2k_out_enable.Enable()
			if self.ngt1js_enabled.GetValue() or self.n2k_enable.GetValue() or self.n2k_out_enable.GetValue():
				self.n2k_can0_enable.Disable()
			else:
				if can_exists:
					self.n2k_can0_enable.Enable()	
			if self.n2k_can0_enable.GetValue() or self.n2k_enable.GetValue() or self.n2k_out_enable.GetValue():
				self.ngt1js_enabled.Disable()
			else:
				self.ngt1js_enabled.Enable()
		else:
			self.can_usb.SetLabel(_('none'))
			self.button_N2K_setting.Disable()
			self.n2k_enable.Disable()
			self.N2K_diagnostic_b.Disable()
			self.n2k_out_enable.Disable()
			self.N2K_diagnostic_out_b.Disable()
			self.ngt1js_enabled.Disable()
			if can_exists:
				self.n2k_can0_enable.Enable()

	def on_n2k_enable(self, e):
		if self.n2k_enable.GetValue():
			self.SK_settings.set_ngt1_enable(True,self.can_device,self.can_speed)
		else:
			self.SK_settings.set_ngt1_enable(False,self.can_device,self.can_speed)
		self.read_n2k()

	def on_n2k_output(self, e):
		if self.n2k_out_enable.GetValue():
			self.conf.set('N2K', 'output', '1')
			subprocess.call(['pkill', '-f', 'diagnostic-N2K-output.py'])
			subprocess.call(['pkill', '-f', 'diagnostic-N2K-input.py'])
			subprocess.call(['pkill', '-f', 'N2K-server_d.py'])
			subprocess.Popen(['python', self.currentpath + '/N2K-server_d.py'])
		else:
			self.conf.set('N2K', 'output', '0')
			subprocess.call(['pkill', '-f', 'N2K-server_d.py'])
		self.read_n2k()
			
	def on_ngt1js_enabled(self, e):
		if self.ngt1js_enabled.GetValue():
			self.SK_settings.set_ngt1js_enable(True,self.can_device,self.can_speed)
		else:
			self.SK_settings.set_ngt1js_enable(False,self.can_device,self.can_speed)
		self.read_n2k()	

	def on_N2K_setting(self, e):
		subprocess.call(['pkill', '-f', 'CAN-USB-stick.py'])
		subprocess.Popen(['python', self.currentpath + '/CAN-USB-stick.py'])
		self.ShowStatusBarBLACK(_('Enable PGNs to transmit in your device.'))

	def on_N2K_diagnostic(self, e):
		subprocess.call(['pkill', '-f', 'diagnostic-N2K-input.py'])
		subprocess.Popen(['python', self.currentpath + '/diagnostic-N2K-input.py'])
		self.ShowStatusBarBLACK(_('Show received PGNs.'))

	def on_N2K_diagnostic_out(self, e):
		subprocess.call(['pkill', '-f', 'diagnostic-N2K-output.py'])
		subprocess.Popen(['python', self.currentpath + '/diagnostic-N2K-output.py'])
		self.ShowStatusBarBLACK(_('Show sent PGNs.'))
					
	def on_n2k_can0_enable(self, e):
		if self.n2k_can0_enable.GetValue():
			self.SK_settings.set_canbus_enable(True)
		else:
			self.SK_settings.set_canbus_enable(False)
		self.read_n2k()

	###########################################Signal K

	def start_SK(self):
		subprocess.call(['sudo', 'systemctl', 'start', 'signalk.socket'])
		subprocess.call(['sudo', 'systemctl', 'start', 'signalk.service'])

	def stop_SK(self):
		subprocess.call(['sudo', 'systemctl', 'stop', 'signalk.service'])
		subprocess.call(['sudo', 'systemctl', 'stop', 'signalk.socket'])
		
	def restart_SK(self):
		seconds = 12
		# stopping sk server
		self.stop_SK()
		# restarting sk server
		self.start_SK()
		for i in range(seconds, 0, -1):
			self.ShowStatusBarRED(_('Restarting Signal K server... ')+str(i))
			time.sleep(1)
		self.ShowStatusBarGREEN(_('Signal K server restarted'))

	def on_diagnostic_SK(self, e):
		subprocess.call(['pkill', '-f', 'diagnostic-SK-input.py'])
		subprocess.Popen(['python', self.currentpath + '/diagnostic-SK-input.py'])

###########################################Main

if __name__ == "__main__":
	conf = Conf()
	currentpath = conf.get('GENERAL', 'op_folder')
	app = wx.App()
	bitmap = wx.Bitmap(currentpath+'/static/icons/openplotter.png',wx.BITMAP_TYPE_PNG)
	splash = wx.SplashScreen(bitmap, wx.SPLASH_CENTRE_ON_SCREEN | wx.SPLASH_TIMEOUT, 500, None, style=wx.SIMPLE_BORDER | wx.STAY_ON_TOP)
	wx.Yield()
	MainFrame().Show()
	app.MainLoop()
